import streamlit as st
import streamlit.components.v1 as components
from pyvis.network import Network
import os
import numpy as np
import secrets
import hashlib
from Crypto.Hash import SHAKE128

def rounded(x):
    if abs(x % 1) == 0.5:
        return int(x + 0.5 if x > 0 else x - 0.5)
    else:
        return(round(x))

# This class was generated by ChatGPT since I didn't 
# understand what was going on here.
class XOF:
    @staticmethod
    def Init():
        return SHAKE128.new()
    
    @staticmethod 
    def Absorb(ctx, data: bytes):
        ctx.update(data)
        return ctx
    
    @staticmethod 
    def Squeeze(ctx, n_bytes: int) -> bytes:
        return ctx.read(n_bytes)

zetas1 = np.array([1,1729,2580,3289,2642,630,1897,848,1062,
                 1919,193,797,2786,3260,569,1746,296,2447,
                 1339,1476,3046,56,2240,1333,1426,2094,535,
                 2882,2393,2879,1974,821,289,331,3253,1756,
                 1197,2304,2277,2055,650,1977,2513,632,2865,
                 33,1320,1915,2319,1435,807,452,1438,2868,
                 1534,2402,2647,2617,1481,648,2474,3110,
                 1227,910,17,2761,583,2649,1637,723,2288,
                 1100,1409,2662,3281,233,756,2156,3015,
                 3050,1703,1651,2789,1789,1847,952,1461,
                 2687,939,2308,2437,2388,733,2337,268,641,
                 1584,2298,2037,3220,375,2549,2090,1645,
                 1063,319,2773,757,2099,561,2466,2594,2804,
                 1092,403,1026,1143,2150,2775,886,1722,
                 1212,1874,1029,2110,2935,885,2154])

zetas2 = np.array([17,-17,2761,-2761,583,-583,2649,-2649,
                   1637,-1637,723,-723,2288,-2288,1100,
                   -1100,1409,-1409,2662,-2662,3281,-3281,
                   233,-233,756,-756,2156,-2156,3015,-3015,
                   3050,-3050,1703,-1703,1651,-1651,2789,
                   -2789,1789,-1789,1847,-1847,952,-952, 
                   1461,-1461,2687,-2687,939,-939,2308,
                   -2308,2437,-2437,2388,-2388,733,-733,
                   2337,-2337,268,-268,641,-641,1584,-1584,
                   2298,-2298,2037,-2037,3220,-3220,375,
                   -375,2549,-2549,2090,-2090,1645,-1645,1063,
                   -1063,319,-319,2773,-2773,757,-757,2099,
                   -2099,561,-561,2466,-2466,2594,-2594, 2804,
                   -2804,1092,-1092,403,-403,1026,-1026, 1143,
                   -1143,2150,-2150,2775,-2775,886,-886, 1722,
                   -1722,1212,-1212,1874,-1874,1029,-1029,
                   2110,-2110,2935,-2935,885,-885,2154,-2154])

# Takes in one variable-length input and produces one
# 32-byte output.
def H(s):
    return(hashlib.sha3_256(s).digest())

# Takes in one variable-length input and produces one
# 32-byte output.
def J(s):
    return(hashlib.shake_256(s).digest(32))

# Takes in one variable-length input and produces two
# 32-byte outputs. 
def G(c):
    digested = hashlib.sha3_512(c).digest()
    a = digested[:32]
    b = digested[32:]
    return a, b

# Takes in a parameter eta (either 2 or 3), one 32-byte,
# input, and one 1-byte input. Produces one (64 x eta)-
# byte output.
def PRF(s, b, eta):
    return(hashlib.shake_256(s + b).digest(64*eta))

# Converts a bit array into an array of bytes.
def BitsToBytes(b):
    l = len(b)//8
    B = np.zeros(l, dtype = np.uint8)
    for i in range(0, len(b)):
        B[i//8] = B[i//8] + b[i]*2**(i % 8)
    return(B)

# Converts a byte array into a bit array.
def BytesToBits(B):
    if type(B) != np.ndarray:
        C = np.frombuffer(B, dtype = np.uint8).copy()
    else:
        C = B.copy()
    l = len(B)
    b = np.zeros(l*8, dtype = np.uint8)
    for i in range(0, len(B)):
        for j in range(0, 8):
            b[8*i + j] = C[i] % 2
            C[i] = C[i]//2
    return(b)

# Takes in a 12-bit integer. (Since q = 3329, the bit length of q is 12.). 
# Returns a d-bit compressed version of the number.
def Compress(x,d):
    return(rounded((2**d/3329)*x) % (2**d))

# Takes a d-bit compressed number and returns the full 12-bit
# version.
def Decompress(y,d):
    return(rounded(3329/(2**d)*y))

# Encodes an array of 256 d-bit integers into a byte array. Takes in
# an integer array F in Z_m where m = 2^d and d < 12 or m = q if d = 12.
# Outputs a byte array B of length 32*d. What it really does is convert from
# integers to bits, and then uses BitsToBytes() to convert from bits to bytes.
def ByteEncode(F, d):
    b = np.zeros(256*d, dtype = np.uint8)
    for i in range(0, 256):
        a = F[i]
        for j in range(0, d):
            b[i*d + j] = a % 2
            a = (a - b[i*d + j])//2
    B = BitsToBytes(b)
    return(B)

# Decodes a byte array into an array of d-bit integers for 1 <= d <= 12.
# Takes in a byte array and produces an integer array.
def ByteDecode(B, d):
    if d < 12:
        m = 2**d
    elif d == 12:
        m = 3329
    F = np.zeros(256, dtype = int)
    b = BytesToBits(B).astype(np.int16)
    for i in range(0,256):
        summation = 0 
        for j in range(0, d):
            summation += (b[i*d + j]*2**j)
        F[i] = summation % m
    return(F)


# Need a bit reversal function. I'm almost certain this function was ChatGPT 
# because there is no pseudocode for this in the standard.
def BitRev7(r):
    m = 0
    for i in range(7):
        m = (m << 1) | (r & 1)  # take LSB of r, shift into m
        r >>= 1
    return m


# Function that takes in a 32-byte seed and two additional indices as input,
# and outputs a pseudorandom element of T_q. This is akin to a uniform
# sampling of T_q.
def SampleNTT(B):
    ctx = XOF.Init()
    ctx = XOF.Absorb(ctx, B)
    j = 0
    a_hat = np.zeros(256, dtype = int)
    while j < 256:
        C = XOF.Squeeze(ctx,3)
        d_1 = C[0] + 256*(C[1] % 16)
        d_2 = (C[1]//16) + 16*C[2]
        if d_1 < 3329:
            a_hat[j] = d_1
            j = j + 1
        if d_2 < 3329 and j < 256:
            a_hat[j] = d_2
            j = j + 1
    return(a_hat)

# Now, we want to be able to sample from a distribution of polynomials
# in R_q, which we denote D_eta(R_q), of small coefficients. Each of the coefficients
# is randomly and independently sampled from a centered binomial distribution (CBD) on Z_q.
# This function, therefore, takes a seed and outputs a pseudorandom sample from said 
# distribution.
def SamplePolyCBD(B, eta):
    f = np.zeros(256, dtype = int)
    b = BytesToBits(B).astype(np.int16)
    for i in range(0, 256):
        summation_x = 0
        for j in range(0, eta):
            summation_x += b[2*i*eta + j]
        summation_y = 0
        for j in range(0, eta):
            summation_y += b[2*i*eta + eta + j]
        f[i] = (summation_x - summation_y) % 3329
    return(f)


# Function to compute the NTT representation of a polynomial in R_q.
# Takes in a numpy array and returns a numpy array.
def NTT(f, zetas1 = zetas1):
    f_hat = f.copy()
    i = 1
    length = 128
    while length >= 2:
        start = 0
        while start < 256:
            zeta = zetas1[i]
            i = i + 1 
            for j in range(start, start + length):
                t = (zeta*f_hat[j + length]) % 3329
                f_hat[j + length] = (f_hat[j] - t) % 3329
                f_hat[j] = (f_hat[j] + t) % 3329
            start = start + 2*length
        length = length // 2
    return(f_hat)

# Function to compute f from f_hat. Takes in a numpy array
# and returns a numpy array.
def INTT(f_hat, zetas1 = zetas1):
    f = f_hat.copy()
    i = 127
    length = 2 
    while length <= 128:
        start = 0
        while start < 256:
            zeta = zetas1[i]
            i = i - 1 
            for j in range(start, start + length):
                t = f[j]
                f[j] = (t + f[j + length]) % 3329
                f[j + length] = (zeta*(f[j + length] - t)) % 3329
            start = start + 2*length
        length = 2*length
    f = (f*3303) % 3329
    return(f)

# Computes the product of two degree-one polynomials in a ring mod q.
# Takes in the coefficients of (a_0 + a_1X) and (b_0 + b_1X), as well as
# gamma from the modulus (X^2 - gamma). 
def BaseCaseMultiply(a_0, a_1, b_0, b_1, gamma):
    a_0, a_1, b_0, b_1, gamma = map(int, (a_0, a_1, b_0, b_1, gamma))
    a_0 = a_0 % 3329
    a_1 = a_1 % 3329
    b_0 = b_0 % 3329
    b_1 = b_1 % 3329
    gamma = gamma % 3329
    c_00 = (a_0 * b_0) % 3329
    c_01 = (a_1 * b_1 * gamma) % 3329
    c_0 = (c_00 + c_01) % 3329
    c_10 = (a_0 * b_1) % 3329
    c_11 = (a_1 * b_0) % 3329
    c_1 = (c_10 + c_11) % 3329
    return(c_0, c_1)

# Multiplies together two polynomials in NTT form. Takes in two numpy arrays 
# and returns a numpy array.
def MultiplyNTTs(f_hat, g_hat, zetas1 = zetas1):
    h_hat = np.zeros(256, dtype = int)
    for i in range(0, 128):
        h_hat[2*i], h_hat[2*i + 1] = BaseCaseMultiply(f_hat[2*i], f_hat[2*i + 1], g_hat[2*i], g_hat[2*i + 1], zetas2[i])
    return(h_hat)

st.set_page_config(layout="wide", page_title="ML-KEM KeyGen Path")
st.title("Understanding the ML-KEM Cryptosystem")
st.markdown("##### In August 2024, the National Institute of Standards and Technology (NIST) announced the approval of three new encryption standards following an eight year process of submission and evaluation, with the *ML-KEM* cryptosystem becoming the new standard for general encryption.")
st.markdown("###### **Why is it needed?**")
st.markdown("""
            - Because the current encryption schemes in place around the globe were built to withstand attacks from *classical* computers, but the rise of *quantum* computers threatens to put the security of these cryptosystems at risk.
            - The ML-KEM was designed specifically to maintain security in a post-quantum world. It will soon be used by government agencies and private companies alike to keep information and communications secure.
            """)
st.markdown("###### **How does it work?**")
st.markdown("""
            - ML-KEM stands for *Module-Lattice-Based Key-Encapsulation-Mechanism*. 
                - 'Module-Lattice-Based' indicates that the encryption scheme is derived from a hard problem in mathematics known as 'Module Learning with Errors' (MLWE). (See the **Security** tab for more information on MLWE.) 
                - 'Key Encapsulation Mechanism' means that the goal of this scheme is to exchange a shared secret key between two parties (we'll call them Alice and Bob), which they can subsequently use in the framework of a symmetric key encryption scheme to exchange encrypted messages, authenticate digital information, etc.
            """)
st.markdown("###### **What does the app do?**")
st.markdown("""
            - This app was designed as an educational tool to help instructors and students alike understand this seemingly daunting encryption scheme and break it down in a simpler way.
                - The Overview tab contains interactive path diagrams illustrating each of the three major steps in the key encapsulation process.
                - The Walkthrough tab shows the user how these processes play out in code, allowing them to select one of the three approved parameter sets and view what real output would look like at each substep.
                - The Security tab offers a glimpse into the impregnability of the ML-KEM, showing first how a toy version of MLWE could theoretically be broken with lattice reduction algorithms but then illustrating how *unsuccessful* such methods would be in attacking the *real* cryptosystem.
            """)


# Making the first path diagram -- Key Generation
@st.cache_data
def generate_keygen_graph():
    net = Network(height="400px", width="100%", directed=True, bgcolor="#ffffffff")

    net.add_node("z", label="z", title="Random 32-byte array generated by Alice.", shape="ellipse", color="seagreen", x=146, y=-581, font={'color': 'white'})
    net.add_node("d", label="d", title="Random 32-byte array generated by Alice.", shape="ellipse", color="seagreen", x=-550, y=-344, font={'color': 'white'})
    net.add_node("k", label="k", title="Model parameter defining the size of our matrix A. \n Takes a value of either 2, 3, or 4.", shape="ellipse", color="seagreen", x=-550, y=-420, font={'color': 'white'})
    net.add_node("G", label="G", title="Hash function. In this case, takes in the concatenation of d \n and k and produces two pseudorandom 32-byte seeds: \n Ï and Ïƒ.", shape="box", color="steelblue", x=-494, y=-383, font={'color': 'white'})
    net.add_node("rho", label="Ï", title="Pseudorandom 32-byte array.", shape="ellipse", color="seagreen", x=-410, y=-552, font={'color': 'white'})
    net.add_node("sigma", label="Ïƒ", title="Pseudorandom 32-byte array.", shape="ellipse", color="seagreen", x=-380, y=-374, font={'color': 'white'})
    net.add_node("PRF1", label="PRF", title="Pseudo-Random Function. Hash function that, in this case, \n takes in one 32-byte array Ïƒ and one 1-byte input N and produces \n one (64 x ğœ‚â‚)-length byte output.", shape="box", color="steelblue", x=-328, y=-435, font={'color': 'white'})
    net.add_node("N", label="N", title="An increasing index value.", shape="ellipse", color="seagreen", x=-328, y=-376, font={'color': 'white'})
    net.add_node("eta1", label="\u03b7\u2081", title="Model parameter taking the value of either 2 or 3.", shape="ellipse", color="seagreen", x=-280, y=-374, font={'color': 'white'})
    net.add_node("PRF2", label="PRF", title="Pseudo-Random Function. Hash function that, in this case, \n takes in one 32-byte array Ïƒ and one 1-byte input N and produces \n one (64 x ğœ‚â‚)-length byte output.", shape="box", color="steelblue", x=-330, y=-314, font={'color': 'white'})
    net.add_node("SPC1", label=" Sample \n Poly \n CBD", title="Takes seed outputted by PRF and samples from a centered \n binomial distribution to obtain polynomials with small coefficients.", shape="box", color="steelblue", x=-209, y=-434, font={'color': 'white'})
    net.add_node("SPC2", label=" Sample \n Poly \n CBD", title="Takes seed outputted by PRF and samples from a centered \n binomial distribution to obtain polynomials with small coefficients.", shape="box", color="steelblue", x=-212, y=-318, font={'color': 'white'})
    net.add_node("s", label="s", title="The secret vector. A k x 1 vector whose entries are coefficient arrays representing \n polynomials with small coefficients in the ring of integers mod q (3329).", shape="ellipse", color="seagreen", x=-105, y=-434, font={'color': 'white'})
    net.add_node("e", label="e", title="The error vector. A k x 1 vector whose entries are coefficient arrays representing \n polynomials with small coefficients in the ring of integers mod q (3329).", shape="ellipse", color="seagreen", x=-105, y=-320, font={'color': 'white'})
    net.add_node("NTT1", label="NTT", title="Computes the NTT representation of a polynomial (128 degree-one polynomials \n instead of 1 255-degree polynomial). Makes multiplication more efficient.", shape="box", color="steelblue", x=-33, y=-435, font={'color': 'white'})
    net.add_node("NTT2", label="NTT", title="Computes the NTT representation of a polynomial (128 degree-one polynomials \n instead of 1 255-degree polynomial). Makes multiplication more efficient.", shape="box", color="steelblue", x=-35, y=-320, font={'color': 'white'})
    net.add_node("s_hat", label="Å", title="NTT representation of s.", shape="ellipse", color="seagreen", x=55, y=-434, font={'color': 'white'})
    net.add_node("e_hat", label="Ãª", title="NTT representation of e.", shape="ellipse", color="seagreen", x=55, y=-319, font={'color': 'white'})
    net.add_node("sNTT", label="Sample \n NTT", title="Takes in a 32-byte seed (Ï in this case) and two indices (i and j) \n and produces pseudorandom elements in the NTT ring.", shape="box", color="steelblue", x=-286, y=-553, font={'color': 'white'})
    net.add_node("i", label="i", title="An increasing index value.", shape="ellipse", color="seagreen", x=-335, y=-493, font={'color': 'white'})
    net.add_node("j", label="j", title="An increasing index value.", shape="ellipse", color="seagreen", x=-253, y=-491, font={'color': 'white'})
    net.add_node("A_hat", label="Ã‚", title="A (k x k) matrix containing elements from the NTT domain \n (NTT representations of polynomials).", shape="ellipse", color="seagreen", x=-167, y=-513, font={'color': 'white'})
    net.add_node("t_hat", label="t\u0302 = Ã‚ Â· Å + Ãª", title="A (k x 1) matrix containing elements from the NTT domain \n (NTT representations of polynomials).", shape="ellipse", color="seagreen", x=-43, y=-513, font={'color': 'white'})
    net.add_node("BE1", label="Byte \n Encode", title="Encodes arrays of 256 integers (i.e. sets of polynomial coefficients) \n into byte arrays for compactness, standardization, etc.", shape="box", color="steelblue", x=151, y=-432, font={'color': 'white'})
    net.add_node("dk_PKE", label="dk_PKE", title="Byte array representation of our secret vector Å.", shape="ellipse", color="seagreen", x=66, y=-513, font={'color': 'white'})
    net.add_node("dk", label="dk", title="Concatention of the secret vector Å, the encapsulation \n key ek, a hashed version of the encapsulation \n key, and random seed z.", shape="database", color="orangered", x=64, y=-581, font={'color': 'white'})
    net.add_node("ek_PKE", label="ek_PKE", title="Byte array containing $\\hat{t}$, as well as Ï so \n that Ã‚ can be reconstructed by Bob. \n This is Alice's public encapsulation key.", shape="ellipse", color="seagreen", x=-241, y=-636, font={'color': 'white'})
    net.add_node("BE2", label="Byte \n Encode", title="Encodes arrays of 256 integers (i.e. sets of polynomial coefficients) \n into byte arrays for compactness, standardization, etc.", shape="box", color="steelblue", x=-44, y=-578, font={'color': 'white'})
    net.add_node("ek", label="ek", title="Renamed to ek for consistency. Bob will use this to \n encode his plaintext (i.e. shared secret key) \n into a ciphertext to send to Alice.", shape="database", color="orangered", x=-128, y=-637, font={'color': 'white'})
    net.add_node("H", label="H", title="Hash function with variable length input and \n a fixed 32-byte pseudorandom output. In this case, takes \n in the encapsulation key ek and produces a hashed \n version of it, which we call h.", shape="box", color="steelblue", x=-59, y=-638, font={'color': 'white'})
    net.add_node("h", label="h", title="Hashed version of the encapsulation key, ek.", shape="ellipse", color="seagreen", x=11, y=-636, font={'color': 'white'})

    net.add_node("start", label = "Alice starts \n here!", shape = "text", font={'color': 'black', 'size': 18, 'face': 'Times New Roman'}, x = -627, y = -382)
    net.add_node("Alice_keep", label = "Alice keeps \n this!", shape = "text", font={'color': 'black', 'size': 18, 'face': 'Times New Roman'}, x = 109, y = -632)
    net.add_node("Alice_send", label = "Alice sends \n this to Bob!", shape = "text", font={'color': 'black', 'size': 18, 'face': 'Times New Roman'}, x = -128, y = -696)

    net.add_node("legend_title",
                 label="Legend:",
                 shape="text",
                 font={'color': 'black', 'size': 20, 'face': 'Times New Roman'},
                 x=-650, y=-720, physics=False)

    net.add_node("Variable", label="Variable", shape="ellipse", color="seagreen",
                 size=15, x=-650, y=-680, physics=False, font = {'color': 'white'})
    net.add_node("Function", label="Function", shape="box", color="steelblue",
                 size=15, x=-650, y=-640, physics=False, font = {'color':'white'})
    net.add_node("Output", label="Output", shape="database", color="orangered",
                  x=-650, y=-590, physics=False, font = {'color':'white'})

    net.add_edge("d", "G", arrows="to", smooth=False)
    net.add_edge("k", "G", arrows="to", smooth=False)
    net.add_edge("G", "rho", arrows="to", smooth=False)
    net.add_edge("G", "sigma", arrows="to", smooth=False)
    net.add_edge("sigma", "PRF1", arrows="to", smooth=False)
    net.add_edge("N", "PRF1", arrows="to", smooth=False)
    net.add_edge("eta1", "PRF1", arrows="to", smooth=False)
    net.add_edge("sigma", "PRF2", arrows="to", smooth=False)
    net.add_edge("N", "PRF2", arrows="to", smooth=False)
    net.add_edge("eta1", "PRF2", arrows="to", smooth=False)
    net.add_edge("PRF1", "SPC1", arrows="to", smooth=False)
    net.add_edge("PRF2", "SPC2", arrows="to", smooth=False)
    net.add_edge("SPC1", "s", arrows="to", smooth=False)
    net.add_edge("SPC2", "e", arrows="to", smooth=False)
    net.add_edge("s", "NTT1", arrows="to", smooth=False)
    net.add_edge("e", "NTT2", arrows="to", smooth=False)
    net.add_edge("NTT1", "s_hat", arrows="to", smooth=False)
    net.add_edge("NTT2", "e_hat", arrows="to", smooth=False)
    net.add_edge("rho", "sNTT", arrows="to", smooth=False)
    net.add_edge("i", "sNTT", arrows="to", smooth=False)
    net.add_edge("j", "sNTT", arrows="to", smooth=False)
    net.add_edge("sNTT", "A_hat", arrows="to", smooth=False)
    net.add_edge("A_hat", "t_hat", arrows="to", smooth=False)
    net.add_edge("s_hat", "t_hat", arrows="to", smooth=False)
    net.add_edge("e_hat", "t_hat", arrows="to", smooth=False)
    net.add_edge("s_hat", "BE1", arrows="to", smooth=False)
    net.add_edge("BE1", "dk_PKE", arrows="to", smooth=False)
    net.add_edge("dk_PKE", "dk", arrows="to", smooth=False)
    net.add_edge("rho", "ek_PKE", arrows="to", smooth=False)
    net.add_edge("BE2", "ek_PKE", arrows="to", smooth=False)
    net.add_edge("t_hat", "BE2", arrows="to", smooth=False)
    net.add_edge("ek_PKE", "ek", arrows="to", smooth=False)
    net.add_edge("ek", "H", arrows="to", smooth=False)
    net.add_edge("H", "h", arrows="to", smooth=False)
    net.add_edge("h", "dk", arrows="to", smooth=False)
    net.add_edge("z", "dk", arrows="to", smooth=False)
    net.add_edge("ek", "dk", arrows="to", smooth=False)
    net.add_edge("eta1", "SPC1", arrows= "to", smooth = False)
    net.add_edge("eta1", "SPC2", arrows= "to", smooth = False)


    net.add_edge("start", "k", arrows = "to", color = "lightgrey", dashes = True, smooth = False)
    net.add_edge("start", "d", arrows = "to", color = "lightgrey", dashes = True, smooth = False)
    net.add_edge("Alice_keep", "dk", arrows = "to", color = "lightgrey", dashes = True, smooth = False)
    net.add_edge("Alice_send", "ek", arrows = "to", color = "lightgrey", dashes = True, smooth = False)

    net.toggle_physics(False)

    options = """
    {
      "autoResize": false,
      "height": "100%",
      "width": "100%",
      "margin": 0,
      "edges": {
        "color": {
          "color": "black",
          "inherit": false 
        },
        "smooth": false
      },
      "nodes": {
        "fixed": {
          "x": false,
          "y": false
        },
        "shapeProperties": {
            "borderRadius": 0
        },
        "font": {
          "face": "Times New Roman",
          "size": 18
        }
      },
      "physics": {
        "enabled": false,
        "stabilization": false
      },
      "interaction": {
        "dragNodes": true, 
        "dragView": true, 
        "zoomView": false
      }
    }
    """
    net.set_options(options)

    html_file = "mlkem_keygen_graph_cached.html" 
    net.save_graph(html_file)
    with open(html_file, 'r', encoding='utf-8') as f:
        html_string = f.read()
    return html_string

# Making the second path diagram -- Encrypt
@st.cache_data
def generate_encaps_graph():
  net = Network(height="550px", width="100%", directed=True, bgcolor="#ffffffff")

  net.add_node("m", label="m", title="Random 32-byte (256-bit) array generated by Bob.", shape="ellipse", color="seagreen", x=-690, y=-828, font={'color': 'white'})
  net.add_node("ek", label="ek", title="Public encapsulation key from Alice containing the byte representation \n of tÌ‚ as well as the pseudorandom 32-byte \n seed Ï so that Bob can reconstruct the public k x k matrix Ã‚.", shape="ellipse", color="seagreen", x=-615, y=-791, font={'color': 'white'})
  net.add_node("BD1", label="Byte \n Decode", title="Function that takes in a byte array and \n returns the original integer array.", shape="box", color="steelblue", x=-537, y=-712, font={'color': 'white'})
  net.add_node("t_hat", label="tÌ‚", title="Extracted from ek. Equal to Ã‚ Â· Å + Ãª.", shape="ellipse", color="seagreen", x=-447, y=-714, font={'color': 'white'})
  net.add_node("G", label="G", title="Hash function. Here, it takes in the concatenation of m and the \n output of function H, and produces two 32-byte outputs, \n K and r.", shape="box", color="steelblue", x=-684, y=-658, font={'color': 'white'})
  net.add_node("H", label="H", title="Hash function. Here, it takes in the encapsulation key, ek, \n and produces one pseudorandom 32-byte array that gets \n passed into the G function.", shape="box", color="steelblue", x=-615, y=-708, font={'color': 'white'})
  net.add_node("rho", label="Ï", title="Pseudorandom 32-byte array used to construct Ã‚.", shape="ellipse", color="seagreen", x=-453, y=-793, font={'color': 'white'})
  net.add_node("sNTT", label="Sample \n NTT", title="Takes in a 32-byte seed (Ï) and two indices (i and j) \n and produces pseudorandom elements in the NTT ring. \n Here, Bob uses the same inputs as Alice did, \n and so the result is the same (Ã‚)", shape="box", color="steelblue", x=-334, y=-792, font={'color': 'white'})
  net.add_node("A_hat", label="Ã‚", title="A k x k matrix containing elements from the NTT domain \n (NTT representations of polynomials).", shape="ellipse", color="seagreen", x=-211, y=-792, font={'color': 'white'})
  net.add_node("BD2", label="Byte \n Decodeâ‚", title="Turns the random 32-byte array, m, into an \n array of 1-bit integers (i.e. 0s and 1s).", shape="box", color="steelblue", x=28, y=-828, font={'color': 'white'})
  net.add_node("K", label="K", title="A 32-byte array, and the eventual shared secret between \n Bob and Alice. Its generation depends on m and ek.", shape="database", color="orangered", x=-763, y=-657, font={'color': 'white'})
  net.add_node("r", label="r", title="A random 32-byte seed.", shape="ellipse", color="seagreen", x=-684, y=-553, font={'color': 'white'})
  net.add_node("i", label="i", title="An increasing index value.", shape="ellipse", color="seagreen", x=-355, y=-735, font={'color': 'white'})
  net.add_node("j", label="j", title="An increasing index value.", shape="ellipse", color="seagreen", x=-312, y=-734, font={'color': 'white'})
  net.add_node("t_hat_y_hat", label="tÌ‚áµ€Â·Å·", title="NTT multiplication of tÌ‚ and Å·.", shape="box", color="steelblue", x=-417, y=-656, font={'color': 'white'})
  net.add_node("Decompress", label="Decompressâ‚", title="Takes each of the individual bits from the output of Byte Decodeâ‚ \n and returns a full 12-bit version of them (becomes \n a representation of a polynomial).", shape="box", color="steelblue", x=29, y=-738, font={'color': 'white'})
  net.add_node("N", label="N", title="An increasing index value.", shape="ellipse", color="seagreen", x=-540, y=-399, font={'color': 'white'})
  net.add_node("eta1", label="Î·â‚", title="Model parameter taking the value of either 2 or 3.", shape="ellipse", color="seagreen", x=-535, y=-636, font={'color': 'white'})
  net.add_node("INTT1", label="NTTâ»Â¹", title="The inverse of the NTT function. Converts back to the \n polynomial ring to get táµ€Â·y.", shape="box", color="steelblue", x=-300, y=-653, font={'color': 'white'})
  net.add_node("mu", label="Î¼", title="Polynomial based on transformations of Bob's random seed, m.", shape="ellipse", color="seagreen", x=30, y=-656, font={'color': 'white'})
  net.add_node("PRF1", label="PRF", title="Pseudo-Random Function. Hash function that, in this case, \n takes in one 32-byte array r and one 1-byte input N and produces \n one (64 x ğœ‚â‚)-length byte output.", shape="box", color="steelblue", x=-537, y=-553, font={'color': 'white'})
  net.add_node("eta2", label="Î·â‚‚", title="Model parameter always equal to 2.", shape="ellipse", color="seagreen", x=-623, y=-443, font={'color': 'white'})
  net.add_node("v", label="v = táµ€y + eâ‚‚ + Î¼", title="Result is a 1 x 1 polynomial with coefficients in \n the ring of polynomials.", shape="ellipse", color="seagreen", x=-100, y=-658, font={'color': 'white'})
  net.add_node("c", label="c \n ", title="Bob's ciphertext to send to Alice. A concatenation of câ‚ and câ‚‚ \n containing information about the random array m \n and therefore the eventual shared secret K.", shape="database", color="orangered", x=-34, y=-347, font={'color': 'white'})
  net.add_node("c1", label="câ‚", title="Just a byte encoded version of u = Aáµ€y + eâ‚.", shape="ellipse", color="seagreen", x=-34, y=-262, font={'color': 'white'})
  net.add_node("SPC1", label=" Sample \n Poly \n CBD", title="Takes seed outputted by PRF and samples from a centered \n binomial distribution to obtain polynomials with small coefficients.", shape="box", color="steelblue", x=-439, y=-567, font={'color': 'white'})
  net.add_node("PRF2", label="PRF", title="Pseudo-Random Function. Hash function that, in this case, \n takes in one 32-byte array r and one 1-byte input N and produces \n one (64 x ğœ‚â‚‚)-length byte output.", shape="box", color="steelblue", x=-685, y=-402, font={'color': 'white'})
  net.add_node("PRF3", label="PRF", title="Pseudo-Random Function. Hash function that, in this case, \n takes in one 32-byte array r and one 1-byte input N and produces \n one (64 x ğœ‚â‚‚)-length byte output.", shape="box", color="steelblue", x=-605, y=-491, font={'color': 'white'})
  net.add_node("d_v", label="dáµ¥", title="Model paramter taking a value of either 4 or 5.", shape="ellipse", color="seagreen", x=52, y=-550, font={'color': 'white'})
  net.add_node("Compress1", label="Compress", title="Compresses each integer coefficient down to a \n dáµ¥ (i.e. 4 or 5)-bit representation.", shape="box", color="steelblue", x=-34, y=-593, font={'color': 'white'})
  net.add_node("c2", label="câ‚‚", title="Just a byte-encoded version of v = táµ€y + eâ‚‚ + Î¼.", shape="ellipse", color="seagreen", x=-34, y=-410, font={'color': 'white'})
  net.add_node("BE2", label="Byte \n Encode", title="Encodes the resulting (k x 1) vector of polynomials with \n dáµ¤-bit integer coefficients into a byte array instead.", shape="box", color="steelblue", x=-111, y=-259, font={'color': 'white'})
  net.add_node("SPC2", label=" Sample \n Poly \n CBD", title="Takes seed outputted by PRF and samples from a centered \n binomial distribution to obtain polynomials with small coefficients.", shape="box", color="steelblue", x=-685, y=-319, font={'color': 'white'})
  net.add_node("SPC3", label=" Sample \n Poly \n CBD", title="Takes seed outputted by PRF and samples from a centered \n binomial distribution to obtain polynomials with small coefficients.", shape="box", color="steelblue", x=-438, y=-484, font={'color': 'white'})
  net.add_node("BE1", label="Byte \n Encode", title="Encodes the resulting array of 256 dáµ¥-bit integer coefficients \n into a byte array instead.", shape="box", color="steelblue", x=-33, y=-493, font={'color': 'white'})
  net.add_node("Compress2", label="Compress", title="Compresses each integer coefficient down to a \n dáµ¤ (i.e. 10 or 11)-bit compressed version of the number. \n Keeps enough precision to ensure correct decryption \n but removes unnecessary information.", shape="box", color="steelblue", x=-216, y=-256, font={'color': 'white'})
  net.add_node("y", label="y", title="A k x 1 vector whose entries are coefficient arrays representing \n polynomials with small coefficients in the ring of integers mod q (3329). \n Sampled from the centered binomial distribution.", shape="ellipse", color="seagreen", x=-338, y=-552, font={'color': 'white'})
  net.add_node("e1", label="eâ‚", title="A k x 1 vector whose entries are coefficient arrays representing \n polynomials with small coefficients in the ring of integers mod q (3329). \n Sampled from the centered binomial distribution.", shape="ellipse", color="seagreen", x=-494, y=-318, font={'color': 'white'})
  net.add_node("e2", label="eâ‚‚", title="A k x 1 vector whose entries are coefficient arrays representing \n polynomials with small coefficients in the ring of integers mod q (3329). \n Sampled from the centered binomial distribution.", shape="ellipse", color="seagreen", x=-101, y=-491, font={'color': 'white'})
  net.add_node("NTT1", label="NTT", title="Computes the NTT representation of y (128 degree-one polynomials \n instead of 1 255-degree polynomial). Makes multiplication more efficient.", shape="box", color="steelblue", x=-270, y=-552, font={'color': 'white'})
  net.add_node("y_hat", label="Å·", title="NTT representation of y.", shape="ellipse", color="seagreen", x=-271, y=-609, font={'color': 'white'})
  net.add_node("A_hat_y_hat", label="Ã‚áµ€Â·Å·", title="NTT multiplication of Ã‚ and Å·. \n More efficient than regular polynomial multiplication.", shape="box", color="steelblue", x=-211, y=-719, font={'color': 'white'})
  net.add_node("INTT2", label="NTTâ»Â¹", title="The inverse of the NTT function. Converts back to the \n polynomial ring to get Aáµ€Â·y.", shape="box", color="steelblue", x=-204, y=-551, font={'color': 'white'})
  net.add_node("u", label="u = Aáµ€y + eâ‚", title="Result is a k x 1 vector of polynomials with coefficients in \n the ring of polynomials.", shape="ellipse", color="seagreen", x=-218, y=-315, font={'color': 'white'})
  net.add_node("d_u", label="dáµ¤", title="Model parameter taking a value of either 10 or 11.", shape="ellipse", color="seagreen", x=-169, y=-191, font={'color': 'white'})

  net.add_node("start", label = "Bob starts \n here!", shape = "text", font={'color': 'black', 'size': 18, 'face': 'Times New Roman'}, x = -616, y = -858)
  net.add_node("Bob_keep", label = "Bob keeps \n this!", shape = "text", font={'color': 'black', 'size': 18, 'face': 'Times New Roman'}, x = -763, y = -590)
  net.add_node("Bob_send", label = "Bob sends \n this to Alice!", shape = "text", font={'color': 'black', 'size': 18, 'face': 'Times New Roman'}, x = 66, y = -347)

  net.add_node("legend_title",
                label="Legend:",
                shape="text",
                font={'color': 'black', 'size': 20, 'face': 'Times New Roman'},
                x=-860, y=-860, physics=False)

  net.add_node("Variable", label="Variable", shape="ellipse", color="seagreen",
                 size=15, x=-860, y=-820, physics=False, font = {'color': 'white'})
  net.add_node("Function", label="Function", shape="box", color="steelblue",
                 size=15, x=-860, y=-775, physics=False, font = {'color':'white'})
  net.add_node("Output", label="Output", shape="database", color="orangered",
                 x=-860, y=-720, physics=False, font = {'color':'white'})


  net.add_edge("m", "G", arrows="to", smooth=False)
  net.add_edge("m", "BD2", arrows="to", smooth=False)
  net.add_edge("ek", "H", arrows="to", smooth=False)
  net.add_edge("ek", "BD1", arrows="to", smooth=False)
  net.add_edge("ek", "rho", arrows="to", smooth=False)
  net.add_edge("BD1", "t_hat", arrows="to", smooth=False)
  net.add_edge("t_hat", "t_hat_y_hat", arrows="to", smooth=False)
  net.add_edge("G", "K", arrows="to", smooth=False)
  net.add_edge("G", "r", arrows="to", smooth=False)
  net.add_edge("H", "G", arrows="to", smooth=False)
  net.add_edge("rho", "sNTT", arrows="to", smooth=False)
  net.add_edge("sNTT", "A_hat", arrows="to", smooth=False)
  net.add_edge("A_hat", "A_hat_y_hat", arrows="to", smooth=False)
  net.add_edge("BD2", "Decompress", arrows="to", smooth=False)
  net.add_edge("r", "PRF1", arrows="to", smooth=False)
  net.add_edge("r", "PRF2", arrows="to", smooth=False)
  net.add_edge("r", "PRF3", arrows="to", smooth=False)
  net.add_edge("i", "sNTT", arrows="to", smooth=False)
  net.add_edge("j", "sNTT", arrows="to", smooth=False)
  net.add_edge("t_hat_y_hat", "INTT1", arrows="to", smooth=False)
  net.add_edge("Decompress", "mu", arrows="to", smooth=False)
  net.add_edge("N", "PRF1", arrows="to", smooth=False)
  net.add_edge("N", "PRF2", arrows="to", smooth=False)
  net.add_edge("N", "PRF3", arrows="to", smooth=False)
  net.add_edge("eta1", "PRF1", arrows="to", smooth=False)
  net.add_edge("INTT1", "v", arrows="to", smooth=False)
  net.add_edge("mu", "v", arrows="to", smooth=False)
  net.add_edge("PRF1", "SPC1", arrows="to", smooth=False)
  net.add_edge("eta2", "PRF2", arrows="to", smooth=False)
  net.add_edge("eta2", "PRF3", arrows="to", smooth=False)
  net.add_edge("v", "Compress1", arrows="to", smooth=False)
  net.add_edge("c1", "c", arrows="to", smooth=False)
  net.add_edge("SPC1", "y", arrows="to", smooth=False)
  net.add_edge("PRF2", "SPC2", arrows="to", smooth=False)
  net.add_edge("PRF3", "SPC3", arrows="to", smooth=False)
  net.add_edge("d_v", "Compress1", arrows="to", smooth=False)
  net.add_edge("d_v", "BE1", arrows="to", smooth=False)
  net.add_edge("Compress1", "BE1", arrows="to", smooth=False)
  net.add_edge("c2", "c", arrows="to", smooth=False)
  net.add_edge("BE2", "c1", arrows="to", smooth=False)
  net.add_edge("y", "NTT1", arrows="to", smooth=False)
  net.add_edge("SPC2", "e1", arrows="to", smooth=False)
  net.add_edge("SPC3", "e2", arrows="to", smooth=False)
  net.add_edge("BE1", "c2", arrows="to", smooth=False)
  net.add_edge("Compress2", "BE2", arrows="to", smooth=False)
  net.add_edge("NTT1", "y_hat", arrows="to", smooth=False)
  net.add_edge("e1", "u", arrows="to", smooth=False)
  net.add_edge("e2", "v", arrows="to", smooth=False)
  net.add_edge("A_hat_y_hat", "INTT2", arrows="to", smooth=False)
  net.add_edge("INTT2", "u", arrows="to", smooth=False)
  net.add_edge("u", "Compress2", arrows="to", smooth=False)
  net.add_edge("d_u", "BE2", arrows="to", smooth=False)
  net.add_edge("d_u", "Compress2", arrows="to", smooth=False)
  net.add_edge("y_hat", "t_hat_y_hat", arrows="to", smooth=False)
  net.add_edge("y_hat", "A_hat_y_hat", arrows="to", smooth=False)
  net.add_edge("eta1", "SPC1", arrows="to", smooth=False)
  net.add_edge("eta2", "SPC2", arrows="to", smooth=False)
  net.add_edge("eta2", "SPC3", arrows="to", smooth=False)

  net.add_edge("start", "m", arrows = "to", color = "lightgrey", dashes = True, smooth = False)
  net.add_edge("start", "ek", arrows = "to", color = "lightgrey", dashes = True, smooth = False)
  net.add_edge("Bob_keep", "K", arrows = "to", color = "lightgrey", dashes = True, smooth = False)
  net.add_edge("Bob_send", "c", arrows = "to", color = "lightgrey", dashes = True, smooth = False)

  net.toggle_physics(False)

  options = """
  {
    "autoResize": false,
    "height": "100%",
    "width": "100%",
    "edges": {
      "color": {
        "color": "black",
        "inherit": false 
      },
      "smooth": false
    },
    "nodes": {
      "fixed": {
        "x": false,
        "y": false
      },
      "shapeProperties": {
          "borderRadius": 0
      },
      "font": {
        "face": "Times New Roman",
        "size": 20
      }
    },
    "physics": {
      "enabled": false,
      "stabilization": false
    },
    "interaction": {
      "dragNodes": true, 
      "dragView": true, 
      "zoomView": false
    }
  }
  """
  net.set_options(options)

  html_file = "ml_kem_graph_cached.html" 
  net.save_graph(html_file)
  with open(html_file, 'r', encoding='utf-8') as f:
      html_string = f.read()
  return html_string

# Make the third path diagram -- decrypt
@st.cache_data
def generate_decaps_graph():
  net = Network(height="550px", width="100%", directed=True, bgcolor="#ffffffff")

  net.add_node("dk", label="dk", title="The concatenation of the secret vector Å, the encapsulation \n key ek, a hashed version of the encapsulation \n key, and a random 32-byte seed z. \n These were generated by Alice in the key generation step.", shape="ellipse", color="seagreen", x=-676, y=-482, font={'color': 'white'})
  net.add_node("c", label="c", title="The ciphertext from Bob. Contains information about \n the secret key K generated by Bob. To be \n decrypted by Alice.", shape="ellipse", color="seagreen", x=-953, y=-478, font={'color': 'white'})
  net.add_node("dk_PKE", label="dk_PKE", title="Extracted from dk. A byte array representation of the \n secret vector Å.", shape="ellipse", color="seagreen", x=-718, y=-333, font={'color': 'white'})
  net.add_node("ek", label="ek", title="Extracted from dk. The original encapsulation key generated \n by Alice in the key generation step \n and used by Bob in the Encaps step.", shape="ellipse", color="seagreen", x=-511, y=-485, font={'color': 'white'})
  net.add_node("h", label="h", title="Extracted from dk. The hashed version of the \n encapsulation key, ek, generated by Alice in key generation.", shape="ellipse", color="seagreen", x=-642, y=-334, font={'color': 'white'})
  net.add_node("z", label="z", title="Extracted from dk. The original random 32-byte seed \n generated by Alice in key generation.", shape="ellipse", color="seagreen", x=-767, y=-365, font={'color': 'white'})
  net.add_node("c_1", label="câ‚", title="Extracted from Bob's ciphertext, c. A byte-encoded \n version of u = Aáµ€y + eâ‚.", shape="ellipse", color="seagreen", x=-836, y=-406, font={'color': 'white'})
  net.add_node("c_2", label="câ‚‚", title="Extracted from Bob's ciphertext, c. A byte-encoded \n version of v = táµ€y + eâ‚‚ + Î¼.", shape="ellipse", color="seagreen", x=-953, y=-187, font={'color': 'white'})
  net.add_node("ML-KEM_Encrypt", label="ML-KEM \n Encaps", title="Using the original encapsulation key and the random \n seeds m' and r' uncovered by Alice, she then \n re-runs the encapsulation scheme to make sure that she \n gets out the same ciphertext as the one she received \n from Bob. This ensures no decapsulation errors in the process \n and also prevents Alice from accidentally using a bogus \n key sent by a hacker. This makes the ML-KEM \n CCA-secure -- even if a hacker sent a bogus key and viewed \n the output of the decapsulation scheme, they still \n wouldn't learn anything because of this implicit rejection process.", shape="box", color="purple", x=-510, y=-358, font={'color': 'white'})
  net.add_node("c_prime", label="c'", title="The outputted ciphertext from Alice's re-encapsulation,\n based on her original encapsulation key, as well as the \n seeds m' and r' recovered from Bob's ciphertext.", shape="ellipse", color="seagreen", x=-389, y=-359, font={'color': 'white'})
  net.add_node("BD1", label="Byte \n Decode", title="Decodes the dk_PKE byte array and converts it back into \n a vector of polynomials with 12-bit integer coefficients.", shape="box", color="steelblue", x=-706, y=-105, font={'color': 'white'})
  net.add_node("J", label="J", title="Hash function. In this case, takes in the concatenation of the ciphertext \n c from 'Bob' and the original random seed z. Returns \n a 32-byte dummy shared secret key. \n Part of the implicit rejection process.", shape="box", color="steelblue", x=-1045, y=-364, font={'color': 'white'})
  net.add_node("d_u", label="dáµ¤", title="Model parameter taking a value of either 10 or 11.", shape="ellipse", color="seagreen", x=-928, y=-285, font={'color': 'white'})
  net.add_node("BD2", label="Byte \n Decode", title="Decodes the ciphertext component câ‚ back into a vector of \n polynomials with dáµ¤ (10 or 11)-bit integer coefficients.", shape="box", color="steelblue", x=-833, y=-325, font={'color': 'white'})
  net.add_node("BD3", label="Byte \n Decode", title="Decodes the ciphertext component câ‚‚ back into an array \n representing a polynomial with dáµ¥ (4 or 5)-bit integer coefficients.", shape="box", color="steelblue", x=-950, y=52, font={'color': 'white'})
  net.add_node("d_v", label="dáµ¥", title="Model paramter taking a value of either 4 or 5.", shape="ellipse", color="seagreen", x=-1023, y=122, font={'color': 'white'})
  net.add_node("cond_1", label="If c = c', \n return K'", title="If the two ciphertexts match, the process returns \n the real shared secret key K'.", shape="circle", color="crimson", x=-319, y=-423, font={'color': 'white'})
  net.add_node("cond_2", label="If c â‰  c', \n return KÌ„", title="If the two ciphertexts, don't match, \n the process returns a dummy secret key instead.", shape="circle", color="crimson", x=-324, y=-296, font={'color': 'white'})
  net.add_node("s_hat", label="Å", title="The NTT representation of our secret vector s.", shape="ellipse", color="seagreen", x=-701, y=48, font={'color': 'white'})
  net.add_node("K_bar", label="KÌ„", title="A dummy secret key for the implicit rejection scheme.", shape="database", color="orangered", x=-1045, y=-270, font={'color': 'white'})
  net.add_node("Decompress1", label="Decompress", title="Returns the vector of polynomials \n with full 12-bit integer coefficients.", shape="box", color="steelblue", x=-831, y=-224, font={'color': 'white'})
  net.add_node("Decompress2", label="Decompress", title="Returns the array representation of the polynomial \n with full 12-bit integers.", shape="box", color="steelblue", x=-946, y=181, font={'color': 'white'})
  net.add_node("f_hat", label="fÌ‚ = Åáµ€Â·Ã»'", title="NTT representation of temporary variable fÌ‚.", shape="ellipse", color="seagreen", x=-829, y=52, font={'color': 'white'})
  net.add_node("u_hat_prime", label="Ã»'", title="NTT representation of u'.", shape="ellipse", color="seagreen", x=-829, y=-21, font={'color': 'white'})
  net.add_node("NTT", label="NTT", title="Computes the NTT representation of u'.", shape="box", color="steelblue", x=-831, y=-95, font={'color': 'white'})
  net.add_node("u_prime", label="u'", title="Should be equivalent to u = Aáµ€y + eâ‚ (assuming no decryption errors \n and that the ciphertext actually came from Bob).", shape="ellipse", color="seagreen", x=-832, y=-170, font={'color': 'white'})
  net.add_node("v_prime", label="v'", title="Should be equivalent to v = táµ€y + eâ‚‚ + Î¼ (asuming no decryption errors \n and that the ciphertext actually came from Bob).", shape="ellipse", color="seagreen", x=-502, y=176, font={'color': 'white'})
  net.add_node("INTT", label="INTT", title="Converts back to the polynomial ring to get f = sáµ€u'.", shape="box", color="steelblue", x=-829, y=113, font={'color': 'white'})
  net.add_node("f", label="f", title="Temporary variable equal to sáµ€u'.", shape="ellipse", color="seagreen", x=-667, y=111, font={'color': 'white'})
  net.add_node("w", label="w = v' - f", title="Polynomial approximately equal to Î¼.", shape="ellipse", color="seagreen", x=-503, y=107, font={'color': 'white'})
  net.add_node("Compress", label="Compress", title="Compresses the polynomial back down to an array of 1-bit integers.", shape="box", color="steelblue", x=-503, y=-4, font={'color': 'white'})
  net.add_node("BE", label="Byte Encode", title="Converts the array of 1-bit integers back into a 32-byte array.", shape="box", color="steelblue", x=-504, y=-122, font={'color': 'white'})
  net.add_node("m_prime", label="m'", title="Should be equivalent to the same 32-byte array, m, \n that Bob generated at the start of the encapsulation step.", shape="ellipse", color="seagreen", x=-506, y=-242, font={'color': 'white'})
  net.add_node("G", label="G", title="Hash function taking in the concatentation of m' and the hash of the encapsulation key. \n Returns two 32-byte outputs, r' and K', which should \n be equivalent to the r and K values generated by Bob.", shape="box", color="steelblue", x=-638, y=-242, font={'color': 'white'})
  net.add_node("r_prime", label="r'", title="Should be equivalent to the pseudorandom 32-byte \n seed, r, that Bob generated in the previous step.", shape="ellipse", color="seagreen", x=-579, y=-291, font={'color': 'white'})
  net.add_node("K_prime", label="K'", title="The secret key. Assuming no decryption errors and that \n the ciphertext actually came from Bob, it \n is equivalent to the secret key, K, that Bob generated.", shape="database", color="orangered", x=-636, y=-164, font={'color': 'white'})

  net.add_node("start", label = "Alice starts \n here!", shape = "text", font={'color': 'black', 'size': 18, 'face': 'Times New Roman'}, x = -811, y = -480)
  net.add_node("fake_output", label = "Output for \n decapsulation errors \n or bogus ciphertext!", shape = "text", font={'color': 'black', 'size': 18, 'face': 'Times New Roman'}, x = -1045, y = -175)
  net.add_node("real_output", label = "Output for \n successful \n decapsulation!", shape = "text", font={'color': 'black', 'size': 18, 'face': 'Times New Roman'}, x = -315, y= -165)

  net.add_node("legend_title",
                label="Legend",
                shape="text",
                font={'color': 'black', 'size': 20, 'face': 'Times New Roman'},
                x=-1230, y=-480, physics=False)

  net.add_node("Variable", label="Variable", shape="ellipse", color="seagreen",
                 size=15, x=-1230, y=-440, physics=False, font = {'color': 'white'})
  net.add_node("Function", label="Function", shape="box", color="steelblue",
                 size=15, x=-1230, y=-395, physics=False, font = {'color':'white'})
  net.add_node("Output", label="Output", shape="database", color="orangered",
                 x=-1230, y=-340, physics=False, font = {'color':'white'})
  net.add_node("Subroutine", label="Subroutine", shape="box", color="purple",
                 x=-1230, y=-285, physics=False, font = {'color':'white'})
  net.add_node("Conditional", label="Conditional", shape="circle", color="crimson",
                 x=-1230, y=-210, physics=False, font = {'color':'white'})

  net.add_edge("dk", "dk_PKE", arrows="to", smooth=False)
  net.add_edge("dk", "ek", arrows="to", smooth=False)
  net.add_edge("dk", "h", arrows="to", smooth=False)
  net.add_edge("dk", "z", arrows="to", smooth=False)
  net.add_edge("c", "c_1", arrows="to", smooth=False)
  net.add_edge("c", "c_2", arrows="to", smooth=False)
  net.add_edge("c", "J", arrows="to", smooth=False)
  net.add_edge("ML-KEM_Encrypt", "c_prime", arrows="to", smooth=False)
  net.add_edge("c_prime", "cond_1", arrows="to", smooth=False)
  net.add_edge("c_prime", "cond_2", arrows="to", smooth=False)
  net.add_edge("dk_PKE", "BD1", arrows="to", smooth=False)
  net.add_edge("ek", "ML-KEM_Encrypt", arrows="to", smooth=False)
  net.add_edge("h", "G", arrows="to", smooth=False)
  net.add_edge("z", "J", arrows="to", smooth=False)
  net.add_edge("c_1", "BD2", arrows="to", smooth=False)
  net.add_edge("c_2", "BD3", arrows="to", smooth=False)
  net.add_edge("BD1", "s_hat", arrows="to", smooth=False)
  net.add_edge("J", "K_bar", arrows="to", smooth=False)
  net.add_edge("d_u", "BD2", arrows="to", smooth=False)
  net.add_edge("d_v", "BD3", arrows="to", smooth=False)
  net.add_edge("d_u", "Decompress1", arrows="to", smooth=False)
  net.add_edge("d_v", "Decompress2", arrows="to", smooth=False)
  net.add_edge("Decompress1", "u_prime", arrows="to", smooth=False)
  net.add_edge("Decompress2", "v_prime", arrows="to", smooth=False)
  net.add_edge("s_hat", "f_hat", arrows="to", smooth=False)
  net.add_edge("u_prime", "NTT", arrows="to", smooth=False)
  net.add_edge("v_prime", "w", arrows="to", smooth=False)
  net.add_edge("u_hat_prime", "f_hat", arrows="to", smooth=False)
  net.add_edge("NTT", "u_hat_prime", arrows="to", smooth=False)
  net.add_edge("f_hat", "INTT", arrows="to", smooth=False)
  net.add_edge("INTT", "f", arrows="to", smooth=False)
  net.add_edge("w", "Compress", arrows="to", smooth=False)
  net.add_edge("Compress", "BE", arrows="to", smooth=False)
  net.add_edge("BE", "m_prime", arrows="to", smooth=False)
  net.add_edge("m_prime", "ML-KEM_Encrypt", arrows="to", smooth=False)
  net.add_edge("m_prime", "G", arrows="to", smooth=False)
  net.add_edge("G", "r_prime", arrows="to", smooth=False)
  net.add_edge("G", "K_prime", arrows="to", smooth=False)
  net.add_edge("r_prime", "ML-KEM_Encrypt", arrows="to", smooth=False)
  net.add_edge("f", "w", arrows="to", smooth=False)
  net.add_edge("BD2", "Decompress1", arrows="to", smooth=False)
  net.add_edge("BD3", "Decompress2", arrows="to", smooth=False)

  net.add_edge("start", "c", arrows = "to", color = "lightgrey", dashes = True, smooth = False)
  net.add_edge("start", "dk", arrows = "to", color = "lightgrey", dashes = True, smooth = False)
  net.add_edge("fake_output", "K_bar", arrows = "to", color = "lightgrey", dashes = True, smooth = False)
  net.add_edge("real_output", "K_prime", arrows = "to", color = "lightgrey", dashes = True, smooth = False)


  net.toggle_physics(False)

  options = """
  {
    "autoResize": false,
    "height": "100%",
    "width": "100%",
    "edges": {
      "color": {
        "color": "black",
        "inherit": false 
      },
      "smooth": false
    },
    "nodes": {
      "fixed": {
        "x": false,
        "y": false
      },
      "shapeProperties": {
          "borderRadius": 0
      },
      "font": {
        "face": "Times New Roman",
        "size": 20
      }
    },
    "physics": {
      "enabled": false,
      "stabilization": false
    },
    "interaction": {
      "dragNodes": true, 
      "dragView": true, 
      "zoomView": false
    }
  }
  """
  net.set_options(options)

  html_file = "ml_kem_graph_cached.html" 
  net.save_graph(html_file)
  with open(html_file, 'r', encoding='utf-8') as f:
      html_string = f.read()
  return html_string


tab1, tab2, tab3 = st.tabs(["# Overview ğŸ§­", "# Walkthrough ğŸ§©", "# Security ğŸ”’"])

with tab1:
    col1, col2, col3 = st.columns([0.05, 0.65, 0.3])
    keygen_graph_html = generate_keygen_graph()
    encaps_graph_html = generate_encaps_graph()
    decaps_graph_html = generate_decaps_graph()

    with col2:
      st.subheader("Key Generation Procedure (Alice)")
    
    col1, col2, col3 = st.columns([0.05, 0.65, 0.3])
    with col2:
      components.html(keygen_graph_html, height=420, scrolling=False)

    with col3:
      st.markdown("""
                  In the key generation procedure, Alice generates a public encapsulation key and a private decapsulation key. She sends the public key over to Bob while keeping the private key secret. In broad terms, Alice:
                  1. Generates a random seed.
                  2. Uses it to sample a $k \\times k$ matrix $A$ and two small $k \\times 1$ vectors $s$ and $e$, each containing degree-255 polynomials with coefficients in the ring of integers $\mathbb{Z}_{3329}$.
                  3. Multiplies $t = As + e$ and sends information about $A$ and $t$ to Bob as the public encapsulation key.
                  4. Keeps the secret vector $s$ to use as the decapsulation key.
                  """)
    with col2:
      st.subheader("Encapsulation Procedure")
    
    col1, col2, col3 = st.columns([0.05, 0.65, 0.3])
    with col2:
      components.html(encaps_graph_html, height = 570, scrolling = False)

    with col3:
        st.markdown("""
                In the key generation procedure, Alice generates a public encapsulation key and a private decapsulation key. She sends the public key over to Bob while keeping the private key secret. In broad terms, Alice:
                1. Generates a random seed.
                2. Uses it to sample a $k \\times k$ matrix $A$ and two small $k \\times 1$ vectors $s$ and $e$, each containing degree-255 polynomials with coefficients in the ring of integers $\mathbb{Z}_{3329}$.
                3. Multiplies $t = As + e$ and sends information about $A$ and $t$ to Bob as the public encapsulation key.
                4. Keeps the secret vector $s$ to use as the decapsulation key.
                """)
    
    with col2:
      st.subheader("Decapsulation Procedure")
    
    col1, col2, col3 = st.columns([0.05, 0.65, 0.3])
    with col2:
      components.html(decaps_graph_html, height = 570, scrolling = False)

# --- Kyber Parameters (Updated with eta2, d_u, d_v) ---
KYBER_PARAMS = {
    "ML-KEM-512: k = 2": {
        "k": 2,
        "eta1": 3,
        "eta2": 2,
        "d_u": 10,
        "d_v": 4
    },
    "ML-KEM-768: k = 3": {
        "k": 3,
        "eta1": 2,
        "eta2": 2,
        "d_u": 10,
        "d_v": 4
    },
    "ML-KEM-1024: k = 4": {
        "k": 4,
        "eta1": 2,
        "eta2": 2,
        "d_u": 11,
        "d_v": 5
    }
}

# --- State Initialization ---
# Initialize session state for all variables needed across steps
if 'walkthrough_phase' not in st.session_state:
    # Phase can be 'KeyGen', 'Encapsulation', 'Decapsulation' or 'None'
    st.session_state.walkthrough_phase = 'None' 
if 'walkthrough_step' not in st.session_state:
    # Index within the current phase's step list (0-indexed)
    st.session_state.walkthrough_step = -1 

# Initialize state for intermediate cryptographic values
if 'rho' not in st.session_state: st.session_state.rho = None
if 'sigma' not in st.session_state: st.session_state.sigma = None
if 's' not in st.session_state: st.session_state.s = None # s vector (pre-NTT)
if 'e' not in st.session_state: st.session_state.e = None # e vector (pre-NTT)
if 'A_hat' not in st.session_state: st.session_state.A_hat = None # A matrix (NTT domain)
if 's_hat' not in st.session_state: st.session_state.s_hat = None # s vector (NTT domain)
if 'e_hat' not in st.session_state: st.session_state.e_hat = None # e vector (NTT domain)
if 't_hat' not in st.session_state: st.session_state.t_hat = None # t vector (NTT domain)
if 'ek' not in st.session_state: st.session_state.ek = None # public key
if 'dk' not in st.session_state: st.session_state.dk = None # secret key

if 'K' not in st.session_state: st.session_state.K = None # Shared secret candidate
if 'r' not in st.session_state: st.session_state.r = None
if 'm' not in st.session_state: st.session_state.m = None # Seed m 
if 'mu' not in st.session_state: st.session_state.mu = None
if 'y' not in st.session_state: st.session_state.y = None
if 'e_1' not in st.session_state: st.session_state.e_1 = None
if 'e_2' not in st.session_state: st.session_state.e_2 = None
if 'u' not in st.session_state: st.session_state.u = None
if 'v' not in st.session_state: st.session_state.v = None
if 'c' not in st.session_state: st.session_state.c = None # Ciphertext c

if 'u_prime' not in st.session_state: st.session_state.u_prime = None
if 'v_prime' not in st.session_state: st.session_state.v_prime = None
if 'f' not in st.session_state: st.session_state.f = None
if 's_hat_prime' not in st.session_state: st.session_state.s_hat_prime = None
if 'm_prime' not in st.session_state: st.session_state.m_prime = None
if 'K_prime' not in st.session_state: st.session_state.K_prime = None
if 'K_bar' not in st.session_state: st.session_state.K_bar = None
if 'message' not in st.session_state: st.session_state.message = None
if 'returned_key' not in st.session_state: st.session_state.returned_key = None
if 'dk_PKE' not in st.session_state: st.session_state.dk_PKE = None
if 'h' not in st.session_state: st.session_state.h = None
if 'z' not in st.session_state: st.session_state.z = None
if 'ek_PKE' not in st.session_state: st.session_state.ek_PKE = None



# -------------------------------------------------------------
# *** INTEGRATION AREA: YOUR CUSTOM ML-KEM FUNCTIONS GO HERE ***
# -------------------------------------------------------------
# These functions now DEMONSTRATE the dependency chain by reading/writing to st.session_state

def keygen_step_1(params):
    if st.session_state.rho is None:
        k = params['k']
        d = secrets.token_bytes(32)
        rho, sigma = G(d + bytes([k]))

        st.session_state.rho = rho
        st.session_state.sigma = sigma
    
    rho = st.session_state.rho
    sigma = st.session_state.sigma

    return (
        f"Ï: {rho} \n"
        f"\n"
        f"Ïƒ: {sigma}"
    )

def keygen_step_2(params, full_output):
    k = params['k']
    if st.session_state.s is None: 
        eta1 = params['eta1']
        
        rho = st.session_state.rho 
        sigma = st.session_state.sigma

        A_hat = np.empty((k,k), dtype = object)
        s = np.empty(k, dtype = object)
        e = np.empty(k, dtype = object)
        N = 0
        for i in range(0, k):
            for j in range(0, k):
                A_hat[i,j] = SampleNTT(rho + bytes([j]) + bytes([i]))
        for i in range(0, k):
            s[i] = SamplePolyCBD(PRF(sigma, bytes([N]), eta1), eta1)
            N += 1
        for i in range(0, k):
            e[i] = SamplePolyCBD(PRF(sigma, bytes([N]), eta1), eta1)
            N += 1
        st.session_state.s = s
        st.session_state.e = e
        st.session_state.A_hat = A_hat

    s = st.session_state.s
    e = st.session_state.e

    s_coeffs = []
    e_coeffs = []
    for i in range(k):
        s_coeffs.append([str(x) for x in s[i][:10]])
        e_coeffs.append([str(x) for x in e[i][:10]])
    
    s_coeffs_str = f"[{', '.join(s_coeffs[0])}, ...]"
    e_coeffs_str = f"[{', '.join(e_coeffs[0])}, ...]"
    for i in range(1,k):
        s_coeffs_str += f",\n[{', '.join(s_coeffs[i])},...]"
        e_coeffs_str += f",\n[{', '.join(e_coeffs[i])},...]"

    s_str = ""
    for i in range(k):
        s_str = s_str + "["
        for j in range(0, 256, 32):
            line = ", ".join(str(x) for x in s[i][j:j+32])
            s_str += line + ",\n"
        s_str = s_str[:-2]
        s_str += "],\n"
    s_str = s_str[:-2]

    e_str = ""
    for i in range(k):
        e_str = e_str + "["
        for j in range(0, 256, 32):
            line = ", ".join(str(x) for x in e[i][j:j+32])
            e_str += line + ",\n"
        e_str = e_str[:-2]
        e_str += "],\n"
    e_str = e_str[:-2]

    if full_output == True:
        return(f"s:\n[{s_str}]\n\n"
               f"e:\n[{e_str}]\n\n")
    
    elif full_output == False:
        return (
        f"s:\n[{s_coeffs_str}]\n\n"
        f"e:\n[{e_coeffs_str}]"
        )

def keygen_step_3(params, full_output):
    k = params['k']
    if st.session_state.s_hat is None:
        s = st.session_state.s
        e = st.session_state.e

        s_hat = np.empty(k, dtype = object)
        e_hat = np.empty(k, dtype = object)

        for i in range(k):
            s_hat[i] = NTT(s[i])
            e_hat[i] = NTT(e[i])
        
        st.session_state.s_hat = s_hat
        st.session_state.e_hat = e_hat
        
    s_hat = st.session_state.s_hat
    e_hat = st.session_state.e_hat

    s_hat_coeffs = []
    e_hat_coeffs = []
    for i in range(k):
        s_hat_coeffs.append([str(x) for x in s_hat[i][:10]])
        e_hat_coeffs.append([str(x) for x in e_hat[i][:10]])
    
    s_hat_coeffs_str = f"[{', '.join(s_hat_coeffs[0])}, ...]"
    e_hat_coeffs_str = f"[{', '.join(e_hat_coeffs[0])}, ...]"
    for i in range(1,k):
        s_hat_coeffs_str += f",\n[{', '.join(s_hat_coeffs[i])},...]"
        e_hat_coeffs_str += f",\n[{', '.join(e_hat_coeffs[i])},...]"

    s_hat_str = ""
    for i in range(k):
        s_hat_str = s_hat_str + "["
        for j in range(0, 256, 32):
            line = ", ".join(str(x) for x in s_hat[i][j:j+32])
            s_hat_str += line + ",\n"
        s_hat_str = s_hat_str[:-2]
        s_hat_str += "],\n"
    s_hat_str = s_hat_str[:-2]

    e_hat_str = ""
    for i in range(k):
        e_hat_str = e_hat_str + "["
        for j in range(0, 256, 32):
            line = ", ".join(str(x) for x in e_hat[i][j:j+32])
            e_hat_str += line + ",\n"
        e_hat_str = e_hat_str[:-2]
        e_hat_str += "],\n"
    e_hat_str = e_hat_str[:-2]

    if full_output == True:
        return(f"Å:\n[{s_hat_str}]\n\n"
               f"Ãª:\n[{e_hat_str}]\n\n")
    
    elif full_output == False:
        return (
        f"Å:\n[{s_hat_coeffs_str}]\n\n"
        f"Ãª:\n[{e_hat_coeffs_str}]"
        )

def keygen_step_4(params, full_output):
    k = params['k']
    A_hat = st.session_state.A_hat
    A_hat_coeffs = []
    for i in range(k):
        A_hat_row = []
        for j in range(k):
            A_hat_row.append([str(x) for x in A_hat[i,j][:10]])
        A_hat_coeffs.append(A_hat_row)

    A_hat_coeffs_str = "["
    for i in range(k):
        A_hat_row_coeffs_str = f"[[{', '.join(A_hat_coeffs[i][0])}, ...]"
        for j in range(1,k):
            A_hat_row_coeffs_str += f",[{', '.join(A_hat_coeffs[i][j])},...]"
        A_hat_coeffs_str += A_hat_row_coeffs_str
        A_hat_coeffs_str += "],\n"
    A_hat_coeffs_str = A_hat_coeffs_str[:-2]
    A_hat_coeffs_str += "]"

    A_hat_str = ""
    for i in range(k):
        A_hat_str = A_hat_str + "["
        for j in range(k):
            A_hat_str = A_hat_str + "["
            for l in range(0, 256, 32):
                line = ", ".join(str(x) for x in A_hat[i,j][l:l+32])
                A_hat_str += line + ",\n"
            A_hat_str = A_hat_str[:-2]
            A_hat_str += "],\n"
        A_hat_str = A_hat_str[:-2]
        A_hat_str += "],\n\n"
    A_hat_str = A_hat_str[:-5]
    A_hat_str += "]]"
    
    if full_output == True:
        return(f"Ã‚:\n[{A_hat_str}]\n\n")
    
    elif full_output == False:
        return (
        f"Ã‚:{A_hat_coeffs_str}"
        )

def keygen_step_5(params, full_output):
    k = params['k']
    if st.session_state.t_hat is None:
        
        A_hat = st.session_state.A_hat
        s_hat = st.session_state.s_hat
        e_hat = st.session_state.e_hat
        
        t_hat = np.empty(k, dtype = object)
        for i in range(k):
            temp = MultiplyNTTs(A_hat[i, 0], s_hat[0])
            for j in range(1,k):
                temp = (temp + MultiplyNTTs(A_hat[i,j], s_hat[j])) % 3329
            temp = (temp + e_hat[i]) % 3329
            t_hat[i] = temp
        
        st.session_state.t_hat = t_hat

    t_hat = st.session_state.t_hat

    t_hat_coeffs = []
    for i in range(k):
        t_hat_coeffs.append([str(x) for x in t_hat[i][:10]])
    
    t_hat_coeffs_str = f"[{', '.join(t_hat_coeffs[0])}, ...]"
    for i in range(1,k):
        t_hat_coeffs_str += f",\n[{', '.join(t_hat_coeffs[i])},...]"

    t_hat_str = ""
    for i in range(k):
        t_hat_str = t_hat_str + "["
        for j in range(0, 256, 32):
            line = ", ".join(str(x) for x in t_hat[i][j:j+32])
            t_hat_str += line + ",\n"
        t_hat_str = t_hat_str[:-2]
        t_hat_str += "],\n"
    t_hat_str = t_hat_str[:-2]

    if full_output == True:
        return(f"t\u0302:\n[{t_hat_str}]\n\n")
    
    elif full_output == False:
        return (
        f"t\u0302:\n[{t_hat_coeffs_str}]\n\n"
        )

def keygen_step_6(params, full_output):
    if st.session_state.ek is None:
        k = params['k']
        t_hat = st.session_state.t_hat
        s_hat = st.session_state.s_hat
        rho = st.session_state.rho

        ek_PKE = ByteEncode(t_hat[0], 12)
        dk_PKE = ByteEncode(s_hat[0], 12)
        for i in range(1, k):
            ek_PKE = np.append(ek_PKE, ByteEncode(t_hat[i], 12))
            dk_PKE = np.append(dk_PKE, ByteEncode(s_hat[i], 12))
        rho_array = np.frombuffer(rho, dtype = np.uint8).copy()
        ek_PKE = np.append(ek_PKE, rho_array)
        ek = ek_PKE

        st.session_state.ek = ek
        st.session_state.dk_PKE = dk_PKE
    
    ek = st.session_state.ek
    dk_PKE = st.session_state.dk_PKE

    ek_list = ek.tolist()      
    ek_coeffs_str = ""

    for i in range(0, len(ek_list), 32):
        line = ", ".join(str(x) for x in ek_list[i:i+32])
        ek_coeffs_str += line + "\n"
    ek_coeffs_str = ek_coeffs_str[:-1]
    
    if full_output == True:
        return(f"ek:\n[{ek_coeffs_str}]")
    elif full_output == False:
        return(f"ek: {ek}")

def keygen_step_7(params, full_output):
    z = secrets.token_bytes(32)
    st.session_state.z = z
    dk_PKE = st.session_state.dk_PKE
    ek = st.session_state.ek
    dk = np.concatenate((dk_PKE, ek, np.frombuffer(H(ek), dtype = np.uint8), np.frombuffer(z, dtype = np.uint8)))
    st.session_state.dk = dk

    dk_list = dk.tolist()      
    dk_coeffs_str = ""

    for i in range(0, len(dk_list), 32):
        line = ", ".join(str(x) for x in dk_list[i:i+32])
        dk_coeffs_str += line + "\n"
    dk_coeffs_str = dk_coeffs_str[:-1]

    if full_output == True:
        return(f"dk:\n[{dk_coeffs_str}]")
    elif full_output == False:
        return(f"dk: {dk}")

def encaps_step_1(params):
    if st.session_state.K is None:
        ek = st.session_state.ek
        m = secrets.token_bytes(32)
        K, r = G(m + H(ek.tobytes()))

        st.session_state.m = m
        st.session_state.K = K
        st.session_state.r = r

    m = st.session_state.m 
    K = st.session_state.K 
    r = st.session_state.r 

    return (
    f"m: {m} \n"
    f"\n"
    f"K: {K} \n"
    f"\n"
    f"r: {r}"
    )

def encaps_step_2(params, full_output):
    k = params['k']
    A_hat = st.session_state.A_hat
    t_hat = st.session_state.t_hat

    t_hat_coeffs = []
    for i in range(k):
        t_hat_coeffs.append([str(x) for x in t_hat[i][:10]])
    
    t_hat_coeffs_str = f"[{', '.join(t_hat_coeffs[0])}, ...]"
    for i in range(1,k):
        t_hat_coeffs_str += f",\n[{', '.join(t_hat_coeffs[i])},...]"

    A_hat_coeffs = []
    for i in range(k):
        A_hat_row = []
        for j in range(k):
            A_hat_row.append([str(x) for x in A_hat[i,j][:10]])
        A_hat_coeffs.append(A_hat_row)

    A_hat_coeffs_str = "["
    for i in range(k):
        A_hat_row_coeffs_str = f"[[{', '.join(A_hat_coeffs[i][0])}, ...]"
        for j in range(1,k):
            A_hat_row_coeffs_str += f",[{', '.join(A_hat_coeffs[i][j])},...]"
        A_hat_coeffs_str += A_hat_row_coeffs_str
        A_hat_coeffs_str += "],\n"
    A_hat_coeffs_str = A_hat_coeffs_str[:-2]
    A_hat_coeffs_str += "]"

    A_hat_str = ""
    for i in range(k):
        A_hat_str = A_hat_str + "["
        for j in range(k):
            A_hat_str = A_hat_str + "["
            for l in range(0, 256, 32):
                line = ", ".join(str(x) for x in A_hat[i,j][l:l+32])
                A_hat_str += line + ",\n"
            A_hat_str = A_hat_str[:-2]
            A_hat_str += "],\n"
        A_hat_str = A_hat_str[:-2]
        A_hat_str += "],\n\n"
    A_hat_str = A_hat_str[:-5]
    A_hat_str += "]]"

    t_hat_str = ""
    for i in range(k):
        t_hat_str = t_hat_str + "["
        for j in range(0, 256, 32):
            line = ", ".join(str(x) for x in t_hat[i][j:j+32])
            t_hat_str += line + ",\n"
        t_hat_str = t_hat_str[:-2]
        t_hat_str += "],\n"
    t_hat_str = t_hat_str[:-2]
    
    if full_output == True:
        return(
            f"t\u0302:\n[{t_hat_str}]\n\n\n"
            f"Ã‚:\n[{A_hat_str}]\n\n"
            )
    
    elif full_output == False:
        return (
        f"t\u0302:\n[{t_hat_coeffs_str}]\n\n"
        f"Ã‚:{A_hat_coeffs_str}"
        )

def encaps_step_3(params, full_output):
    k = params['k']
    if st.session_state.e_1 is None:
        eta1 = params['eta1']
        eta2 = params['eta2']
        r = st.session_state.r
        N = 0
        y = np.empty(k, dtype = object)
        for i in range(k):
            y[i] = SamplePolyCBD(PRF(r, bytes([N]), eta1), eta1)
            N += 1 
        e_1 = np.empty(k, dtype = object)
        for i in range(k):
            e_1[i] = SamplePolyCBD(PRF(r, bytes([N]), eta2), eta2)
            N += 1
        e_2 = SamplePolyCBD(PRF(r, bytes([N]), eta2), eta2)
        y_hat = np.empty(k, dtype = object)
        for i in range(k):
            y_hat[i] = NTT(y[i])
        st.session_state.y = y
        st.session_state.y_hat = y_hat
        st.session_state.e_1 = e_1
        st.session_state.e_2 = e_2
    y = st.session_state.y
    e_1 = st.session_state.e_1
    e_2 = st.session_state.e_2
    y_hat = st.session_state.y_hat

    y_coeffs = []
    for i in range(k):
        y_coeffs.append([str(x) for x in y[i][:10]])
    y_coeffs_str = f"[{', '.join(y_coeffs[0])}, ...]"
    for i in range(1,k):
        y_coeffs_str += f",\n[{', '.join(y_coeffs[i])},...]"

    y_str = ""
    for i in range(k):
        y_str = y_str + "["
        for j in range(0, 256, 32):
            line = ", ".join(str(x) for x in y[i][j:j+32])
            y_str += line + ",\n"
        y_str = y_str[:-2]
        y_str += "],\n"
    y_str = y_str[:-2]

    e_1_coeffs = []
    for i in range(k):
        e_1_coeffs.append([str(x) for x in e_1[i][:10]])
    e_1_coeffs_str = f"[{', '.join(e_1_coeffs[0])}, ...]"
    for i in range(1,k):
        e_1_coeffs_str += f",\n[{', '.join(e_1_coeffs[i])},...]"

    e_1_str = ""
    for i in range(k):
        e_1_str = e_1_str + "["
        for j in range(0, 256, 32):
            line = ", ".join(str(x) for x in e_1[i][j:j+32])
            e_1_str += line + ",\n"
        e_1_str = e_1_str[:-2]
        e_1_str += "],\n"
    e_1_str = e_1_str[:-2]

    e_2_coeffs = [str(x) for x in e_2[:10]]
    e_2_coeffs_str = f"[{', '.join(e_2_coeffs)}, ...]"

    e_2_list = e_2.tolist()      
    e_2_str = ""
    for i in range(0, len(e_2_list), 32):
        line = ", ".join(str(x) for x in e_2_list[i:i+32])
        e_2_str += line + "\n"
    e_2_str = e_2_str[:-1]

    y_hat_coeffs = []
    for i in range(k):
        y_hat_coeffs.append([str(x) for x in y_hat[i][:10]])
    y_hat_coeffs_str = f"[{', '.join(y_hat_coeffs[0])}, ...]"
    for i in range(1,k):
        y_hat_coeffs_str += f",\n[{', '.join(y_hat_coeffs[i])},...]"
    
    y_hat_str = ""
    for i in range(k):
        y_hat_str = y_hat_str + "["
        for j in range(0, 256, 32):
            line = ", ".join(str(x) for x in y_hat[i][j:j+32])
            y_hat_str += line + ",\n"
        y_hat_str = y_hat_str[:-2]
        y_hat_str += "],\n"
    y_hat_str = y_hat_str[:-2]

    if full_output == True:
        return(f"y:\n[{y_str}]\n\n"
               f"e_1:\n[{e_1_str}]\n\n"
               f"e_2:\n[{e_2_str}]\n\n"
               f"Å·:\n[{y_hat_str}]\n\n")
    elif full_output == False:
        return (
        f"y:\n[{y_coeffs_str}]\n\n"
        f"e_1:\n[{e_1_coeffs_str}]\n\n"
        f"e_2:\n{e_2_coeffs_str}\n\n"
        f"Å·:\n[{y_hat_coeffs_str}]\n\n"
        )

def encaps_step_4(params, full_output):
    if st.session_state.mu is None:
        m = st.session_state.m
        int_array = ByteDecode(m,1)
        mu = np.array([Decompress(piece,1) for piece in int_array]) % 3329
        st.session_state.mu = mu
    
    mu = st.session_state.mu 
    mu_coeffs = [str(x) for x in mu[:10]]
    mu_coeffs_str = f"[{', '.join(mu_coeffs)}, ...]"

    mu_list = mu.tolist()      
    mu_str = ""
    for i in range(0, len(mu_list), 32):
        line = ", ".join(str(x) for x in mu_list[i:i+32])
        mu_str += line + "\n"
    mu_str = mu_str[:-1]

    if full_output == True:
        return(f"Î¼:\n[{mu_str}]\n\n")
    elif full_output == False:
        return(f"Î¼:\n{mu_coeffs_str}\n\n")

def encaps_step_5(params, full_output):
    k = params['k']
    if st.session_state.u is None:
        A_hat = st.session_state.A_hat
        y_hat = st.session_state.y_hat
        e_1 = st.session_state.e_1
        temp_hat = np.empty(k, dtype = object)
        A_hat_T = A_hat.T
        for i in range(k):
            temp = MultiplyNTTs(A_hat_T[i, 0], y_hat[0])
            for j in range(1,k):
                temp = (temp + MultiplyNTTs(A_hat_T[i,j], y_hat[j])) % 3329
            temp_hat[i] = INTT(temp)
        u = np.empty(k, dtype = object)
        for i in range(k):
            u[i] = (temp_hat[i] + e_1[i]) % 3329
        st.session_state.u = u
    u = st.session_state.u 

    u_coeffs = []
    for i in range(k):
        u_coeffs.append([str(x) for x in u[i][:10]])
    
    u_coeffs_str = f"[{', '.join(u_coeffs[0])}, ...]"
    for i in range(1,k):
        u_coeffs_str += f",\n[{', '.join(u_coeffs[i])},...]"

    u_str = ""
    for i in range(k):
        u_str = u_str + "["
        for j in range(0, 256, 32):
            line = ", ".join(str(x) for x in u[i][j:j+32])
            u_str += line + ",\n"
        u_str = u_str[:-2]
        u_str += "],\n"
    u_str = u_str[:-2]

    if full_output == True:
        return(f"u:\n[{u_str}]\n\n")
    
    elif full_output == False:
        return (f"u:\n[{u_coeffs_str}]\n\n")

def encaps_step_6(params, full_output):
    k = params['k']
    if st.session_state.v is None:
        t_hat = st.session_state.t_hat
        y_hat = st.session_state.y_hat
        e_2 = st.session_state.e_2
        mu = st.session_state.mu
        temp = MultiplyNTTs(t_hat[0], y_hat[0])
        for i in range(1, k):
            temp = (temp + MultiplyNTTs(t_hat[i], y_hat[i])) % 3329
        v = (INTT(temp) + e_2 + mu) % 3329
        st.session_state.v = v
    v = st.session_state.v 
    v_coeffs = [str(x) for x in v[:10]]
    v_coeffs_str = f"[{', '.join(v_coeffs)}, ...]"

    v_list = v.tolist()      
    v_str = ""
    for i in range(0, len(v_list), 32):
        line = ", ".join(str(x) for x in v_list[i:i+32])
        v_str += line + "\n"
    v_str = v_str[:-1]

    if full_output == True:
        return(f"v:\n[{v_str}]\n\n")
    elif full_output == False:
        return(f"v:\n{v_coeffs_str}\n\n")

def encaps_step_7(params, full_output):
    k = params['k']
    d_u = params['d_u']
    d_v = params['d_v']
    if st.session_state.c is None:
        u = st.session_state.u 
        v = st.session_state.v 
        c_1 = ByteEncode(np.array([Compress(u[0][i], d_u) for i in range(256)]), d_u)
        for i in range(1,k):
            c_1 = np.append(c_1, ByteEncode(np.array([Compress(u[i][j], d_u) for j in range(256)]), d_u))
        c_2 = ByteEncode(np.array([Compress(v[i], d_v) for i in range(256)]), d_v)
        c = np.concatenate((c_1,c_2))
        st.session_state.c = c
    c = st.session_state.c 

    c_list = c.tolist()      
    c_coeffs_str = ""

    for i in range(0, len(c_list), 32):
        line = ", ".join(str(x) for x in c_list[i:i+32])
        c_coeffs_str += line + "\n"
    c_coeffs_str = c_coeffs_str[:-1]

    if full_output == True:
        return(f"c:\n[{c_coeffs_str}]")
    elif full_output == False:
        return(f"c: {c}")

def decaps_step_1(params,full_output):
    k = params['k']
    d_u = params['d_u']
    d_v = params['d_v']
    if st.session_state.u_prime is None:
        dk = st.session_state.dk
        c = st.session_state.c
        dk_PKE = dk[0: 384*k]
        st.session_state.dk_PKE = dk_PKE
        ek_PKE = dk[384*k: 768*k + 32]
        st.session_state.ek_PKE = ek_PKE
        h = dk[768*k + 32: 768*k + 64]
        st.session_state.h = h
        z = dk[768*k + 64: 768*k + 96]
        st.session_state.z = z
        c_1 = c[0: 32*d_u*k]
        u_prime = np.empty(k, dtype = object)
        for i in range(k):
            u_prime[i] = ByteDecode(c_1[32*d_u*i : 32*d_u*(i + 1)], d_u)
            u_prime[i] = np.array([Decompress(u_prime[i][j], d_u) for j in range(256)])
        st.session_state.u_prime = u_prime

    u_prime = st.session_state.u_prime
    u_prime_coeffs = []
    for i in range(k):
        u_prime_coeffs.append([str(x) for x in u_prime[i][:10]])
    u_prime_coeffs_str = f"[{', '.join(u_prime_coeffs[0])}, ...]"
    for i in range(1,k):
        u_prime_coeffs_str += f",\n[{', '.join(u_prime_coeffs[i])},...]"

    u_prime_str = ""
    for i in range(k):
        u_prime_str = u_prime_str + "["
        for j in range(0, 256, 32):
            line = ", ".join(str(x) for x in u_prime[i][j:j+32])
            u_prime_str += line + ",\n"
        u_prime_str = u_prime_str[:-2]
        u_prime_str += "],\n"
    u_prime_str = u_prime_str[:-2]

    if full_output == True:
        return(f"u':\n[{u_prime_str}]\n\n")
    
    elif full_output == False:
        return (f"u':\n[{u_prime_coeffs_str}]\n\n")

def decaps_step_2(params,full_output):
    k = params['k']
    d_u = params['d_u']
    d_v = params['d_v']
    if st.session_state.v_prime is None:
        c = st.session_state.c 
        c_2 = c[32*d_u*k: 32*(d_u*k + d_v)]
        v_prime = ByteDecode(c_2, d_v)
        v_prime = np.array([Decompress(v_prime[i], d_v) for i in range(256)])
        st.session_state.v_prime = v_prime
    v_prime = st.session_state.v_prime
    v_prime_coeffs = [str(x) for x in v_prime[:10]]
    v_prime_coeffs_str = f"[{', '.join(v_prime_coeffs)}, ...]"

    v_prime_list = v_prime.tolist()      
    v_prime_str = ""
    for i in range(0, len(v_prime_list), 32):
        line = ", ".join(str(x) for x in v_prime_list[i:i+32])
        v_prime_str += line + "\n"
    v_prime_str = v_prime_str[:-1]

    if full_output == True:
        return(f"v':\n[{v_prime_str}]\n\n")
    elif full_output == False:
        return(f"v':\n{v_prime_coeffs_str}\n\n")

def decaps_step_3(params,full_output):
    k = params['k']
    if st.session_state.s_hat_prime is None:
        dk_PKE = st.session_state.dk_PKE
        s_hat = np.empty(k, dtype = object)
        for i in range(k):
            s_hat[i] = ByteDecode(dk_PKE[384*i: 384*(i + 1)], 12)
        st.session_state.s_hat_prime = s_hat
    s_hat = st.session_state.s_hat_prime
    s_hat_coeffs = []
    for i in range(k):
        s_hat_coeffs.append([str(x) for x in s_hat[i][:10]])
    
    s_hat_coeffs_str = f"[{', '.join(s_hat_coeffs[0])}, ...]"
    for i in range(1,k):
        s_hat_coeffs_str += f",\n[{', '.join(s_hat_coeffs[i])},...]"

    s_hat_str = ""
    for i in range(k):
        s_hat_str = s_hat_str + "["
        for j in range(0, 256, 32):
            line = ", ".join(str(x) for x in s_hat[i][j:j+32])
            s_hat_str += line + ",\n"
        s_hat_str = s_hat_str[:-2]
        s_hat_str += "],\n"
    s_hat_str = s_hat_str[:-2]

    if full_output == True:
        return(f"Å:\n[{s_hat_str}]\n\n")
    
    elif full_output == False:
        return (f"Å:\n[{s_hat_coeffs_str}]\n\n")

def decaps_step_4(params, full_output):
    k = params['k']
    if st.session_state.f is None:
        s_hat = st.session_state.s_hat_prime
        u_prime = st.session_state.u_prime
        u_prime_hat = np.empty(k, dtype = object)
        for i in range(k):
            u_prime_hat[i] = NTT(u_prime[i])
        temp = MultiplyNTTs(s_hat[0], u_prime_hat[0])
        for i in range(1, k):
            temp = (temp + MultiplyNTTs(s_hat[i], u_prime_hat[i])) % 3329
        temp = INTT(temp)
        st.session_state.f = temp
    temp = st.session_state.f
    temp_coeffs = [str(x) for x in temp[:10]]
    temp_coeffs_str = f"[{', '.join(temp_coeffs)}, ...]"

    f_list = temp.tolist()      
    f_str = ""
    for i in range(0, len(f_list), 32):
        line = ", ".join(str(x) for x in f_list[i:i+32])
        f_str += line + "\n"
    f_str = f_str[:-1]

    if full_output == True:
        return(f"f:\n[{f_str}]\n\n")
    elif full_output == False:
        return(f"f:\n{temp_coeffs_str}\n\n")

def decaps_step_5(params):
    if st.session_state.m_prime is None:
        v_prime = st.session_state.v_prime
        temp = st.session_state.f
        w = (v_prime - temp) % 3329
        m = np.array([Compress(w[i], 1) for i in range(256)])
        m_prime= ByteEncode(m, 1)
        st.session_state.m_prime = m_prime 
    m_prime = st.session_state.m_prime

    return (f"m': {m_prime.tobytes()}")

def decaps_step_6(params):
    if st.session_state.K_prime is None:
        m_prime = st.session_state.m_prime
        h = st.session_state.h
        K_prime, r_prime = G(m_prime.tobytes() + h.tobytes())
        st.session_state.K_prime = K_prime 
        st.session_state.r_prime = r_prime
    K_prime = st.session_state.K_prime 
    r_prime = st.session_state.r_prime 

    return(f"K': {K_prime}")

def decaps_step_7(params):
    if st.session_state.K_bar is None:
        z = st.session_state.z 
        c = st.session_state.c
        K_bar = J(z.tobytes() + c.tobytes())
        st.session_state.K_bar = K_bar
    K_bar = st.session_state.K_bar 
    return(f"KÌ„: {K_bar}")

def decaps_step_8(params):
    k = params['k']
    d_v = params['d_v']
    d_u = params['d_u']
    eta1 = params['eta1']
    eta2 = params['eta2']
    if st.session_state.message is None:
        ek_PKE = st.session_state.ek_PKE 
        r_prime = st.session_state.r_prime 
        m_prime = st.session_state.m_prime 
        c = st.session_state.c
        K_bar = st.session_state.K_bar
        K_prime = st.session_state.K_prime
        N = 0
        t_hat = np.empty(k, dtype = object)
        for i in range(0, k):
            chunk = ek_PKE[384*i : 384*(i+1)]
            t_hat[i] = ByteDecode(chunk,12)
        rho = ek_PKE[384*k: 384*k + 32]
        A_hat = np.empty((k,k), dtype = object)
        # This is the part that could be bypassed if A_hat was stored instead.
        for i in range(k):
            for j in range(k):
                A_hat[i,j] = SampleNTT(rho.tobytes() + bytes([j]) + bytes([i]))
        y = np.empty(k, dtype = object)
        for i in range(k):
            y[i] = SamplePolyCBD(PRF(r_prime, bytes([N]), eta1), eta1)
            N += 1 
        e_1 = np.empty(k, dtype = object)
        for i in range(k):
            e_1[i] = SamplePolyCBD(PRF(r_prime, bytes([N]), eta2), eta2)
            N += 1
        e_2 = SamplePolyCBD(PRF(r_prime, bytes([N]), eta2), eta2)
        y_hat = np.empty(k, dtype = object)
        for i in range(k):
            y_hat[i] = NTT(y[i])
        temp_hat = np.empty(k, dtype = object)
        A_hat_T = A_hat.T
        for i in range(k):
            temp = MultiplyNTTs(A_hat_T[i, 0], y_hat[0])
            for j in range(1,k):
                temp = (temp + MultiplyNTTs(A_hat_T[i,j], y_hat[j])) % 3329
            temp_hat[i] = INTT(temp)
        u = np.empty(k, dtype = object)
        for i in range(k):
            u[i] = (temp_hat[i] + e_1[i]) % 3329
        int_array = ByteDecode(m_prime,1)
        mu = np.array([Decompress(piece,1) for piece in int_array]) % 3329
        temp = MultiplyNTTs(t_hat[0], y_hat[0])
        for i in range(1, k):
            temp = (temp + MultiplyNTTs(t_hat[i], y_hat[i])) % 3329
        v = (INTT(temp) + e_2 + mu) % 3329
        c_1 = ByteEncode(np.array([Compress(u[0][i], d_u) for i in range(256)]), d_u)
        for i in range(1,k):
            c_1 = np.append(c_1, ByteEncode(np.array([Compress(u[i][j], d_u) for j in range(256)]), d_u))
        c_2 = ByteEncode(np.array([Compress(v[i], d_v) for i in range(256)]), d_v)
        c_prime = np.concatenate((c_1,c_2))

        if np.any(c != c_prime):
            message = "Implicit Rejection Procedure invoked. Returning dummy key:"
            K_prime = K_bar
        else:
            message = "Decryption successful. Shared secret key, K, returned below:"
        st.session_state.returned_key = K_prime
        st.session_state.message = message

    message = st.session_state.message
    returned_key = st.session_state.returned_key

    return(
        f"{message} \n"
        f"{returned_key}"
    )





# -------------------------------------------------------------
# --- Walkthrough Steps Definition (using the stateful functions) ---
# -------------------------------------------------------------

KEYGEN_STEPS = [
    {
        "title": "Generating Seeds",
        "description": "Alice starts off by generating a random 32-byte array, $d$, as a seed for the key generation process. She passes the concatentation of $d$ and the model parameter $k$ into a hash function, G. This function produces two pseudo-random 32-byte seeds $Ï$ and $Ïƒ$, which will be used in subsequent steps. $Ï$ and $Ïƒ$ look like this:",
        "action": keygen_step_1
    },
    {
        "title": "Sampling the Secret and Error Vectors",
        "description": f"Alice now takes $\\sigma$, an increasing integer index $N$, and the model parameter $\\eta_1$, and she passes these values through a hash function called PRF (Pseudo-Random Function). This function produces a seed that Alice then inputs into a random sampling function called Sample Poly CBD, which stands for 'Sample Polynomial from Centered Binomial Distribution.' In practice, it simply allows her to sample from the distribution of polynomials in $R_q$ with *small coefficients*. Alice executes this process multiple times to produce two (k x 1) vectors $e$ and $s$, each of which contain entries of 256-integer arrays representing coefficients of polynomials in $R_q$. The first vector $e$ represents an error (or noise) vector, and the second vector $s$d serves as the 'secret vector' solution to $t = As + e$. Shown below are the first ten coefficients of each entry in both vectors. Notice how the entries in both vectors are either near 0 or near the modulus $q = 3329$. Because the ML-KEM cryptosystem takes place in the ring $R_q$, the integers near q are also 'small' since 3328 % 3229 = -1, for example.",
        "action": keygen_step_2 
    },
    {
        "title": "Converting $s$ and $e$ to NTT Representations",
        "description": "Because this cryptosystem needs to be efficient, instead of doing traditional polynomial multiplication in the quotient ring $R_q$ (called negacyclic convolution), the algorithm utilizes something called Number Theoretic Transforms (NTTs). NTTs allow us to represent a full 255-degree polynomial as 128 degree-1 polynomials, making polynomial multiplications *much* faster. For example, the multiplication $A \cdot s$ can be formulated instead as $NTT^{-1}(\hat{A} \cdot \hat{s})$. So, in this step, Alice converts the polynomial entries of $s$ and $e$ into their NTT representations. Although each output still looks like an integer array of length 256, it is implied that every two coefficients represent a distinct degree-1 polynomial.",
        "action": keygen_step_3
    },
    {
        "title": "Generating Ã‚",
        "description": "Turning her attention now to the pseudorandom seed Ï generated in step 1, Alice passes this value and the two integer indices $i$ and $j$ into the Sample NTT function. This function generally returns one pseudorandom polynomial representation in the NTT domain. Here, Alice calls it several times to build a (k x k) matrix Ã‚, with each entry containing 128 degree-1 polynomials. Here's what Ã‚ looks like:",
        "action": keygen_step_4
    },
    {
        "title": "Calculating t\u0302",
        "description": "Using the variables Ã‚, $\hat{s}$, and $\hat{e}$ generated in the previous steps, Alice now computes $\hat{t} = \hat{A} \cdot \hat{s} + \hat{e}$. This equation is the basis of the cryptosystem, based on the module learning with errors problem. Essentially, if one party only knows the values of $\hat{t}$ and $\hat{A}$ but not $\hat{e}$, it is very, very difficult to recover $\hat{s}$. Here's what the variable $\hat{t}$ looks like at the end of this step:",
        "action": keygen_step_5
    },
    {
        "title": "Packaging Up the Encapsulation Key",
        "description": "At this point, Alice is ready to construct the public encapsulation key (ek) to send over to Bob. Ek consists of the vector $\hat{t}$ that she just calculated in the previous step, as well as the public key matrix $\hat{A}$. To add another layer of security to the model, however, she doesn't send over either element explicitly. Since $\hat{A}$ was generated deterministically via the Sample NTT function with the seed $\\rho$, she only needs to send $\\rho$ over for Bob to regenerate $\hat{A}$ himself. Furthermore, she converts $\hat{t}$ from an integer array into a byte array representation, though a simple function can convert it back for Bob. With $\hat{A}$ and $\hat{t}$, Bob can encode a 'message' to Alcie that only she, with knowledge of the variables $\hat{s}$ and $\hat{e}$, can decrypt. In this case, the 'message' is actually a key itself -- a shared secret key that Alice and Bob can then use to carry out *symmetric* key encryption. Therefore, in this step, Alice constructs ek by concatenating a byte array representation of $\hat{t}$ with $\\rho$, and she sends it over to Bob. Here's what ek looks like when she sends it over:",
        "action": keygen_step_6
    },
    {
        "title": "Packaging Up the Decapsulation Key",
        "description": "Lastly, the process must also return a decapsulation key for Alice, so that she can eventually use it to decrypt the ciphertext and uncover the shared secret key, K, from Bob. The main element she needs for this decapsulation process is the secret vector $\hat{s}$, and so she byte encodes the vector into the variable dk_PKE. However, that's not all! In the end stage of the decapsulation process, Alice is going to want to carry out a mechanism called implicit rejection, which basically ensures that there were no errors in the decapsulation process and also gives the scheme CCA-level security. Don't worry to much about this part just yet, but it just means that she has to add some extra stuff into the complete decapsulation key, dk. Alice starts with dk_PKE, which, as we said, is just the byte encoded version of $\hat{s}$. Then, she adds to it the encapsulation key, ek, that she just sent to Bob, as well as a hash of the encapsulation key (h) and a random 32-byte array, z. All of these other elements of dk will come into play in the decapsulation step of the ML-KEM process, so she keeps them secret until then. Here is what dk looks like at the end of this step:",
        "action": keygen_step_7
    }
]

ENCAPSULATION_STEPS = [
    {
        "title": "Generating the Shared Secret $K$",
        "description": "In the encapsulation procedure, Bob generates a shared secret, K, to serve as a secret key for future communication with Alice in a symmetric (or private key) encryption scheme, and he uses Alice's encapsulation key to send over just enough information for her to determine the secret. The process starts off with Bob generating a random 32-byte array, $m$. He then takes the encapsulation key, $ek$, that he just received from Alice and passes it through a hash function, $H$. The output of this hash function and the random byte array, $m$, are then inputted into a different hash function, $G$, to get out two pseudo-random 32-byte outputs, $K$ and $r$. $K$ is the secret key that Bob refrains from sharing with anybody, and $r$ will be used as a seed in a later step of the encapsulation process. The values of the two variables are shown below:",
        "action": encaps_step_1
    },
    {
        "title": "Reconstructing Ã‚ and t\u0302 from $ek$",
        "description": "Now, Bob returns to the encapsulation key, $ek$ that he received from Alice and he separates out the byte encoded array of t\u0302 and the pseudo-random byte array, $\\rho$. He passes byte encoded t\u0302 through the Byte Decode function to get out t\u0302 (the NTT representation of Alice's original vector $t$ in $As + e = t$). Bob then passes $\\rho$ through the Sample NTT function along with increasing indices $i$ and $j$, just like Alice did in Key Generation, to obtain the same $k \\times k$ matrix $\hat{A}$ that Alice used. Thus, the public key $(\hat{A}, \hat{t})$ has been recovered by Bob. You can go back to the Key Generation procedure to see that they are the same!",
        "action": encaps_step_2 
    },
    {
        "title": "Sampling the Randomizer and Noise Variables",
        "description": "Before Bob can even think about transmitting the secret key to Alice, he needs to sample three more variables to use in the subsequent process. To do so, Bob returns to the pseudo-random 32-byte array, $r$, that he generated in the first step of the encapsulation procedure. He passes $r$, one of two model parameters $\\eta_1$ (equal to 2 or 3) or $\\eta_2$ (equal to 2), and an increasing integer index $N$ into the PRF and Sample Poly CBD functions, just like Alice did in step 2 of Key Generation. He does this three times to obtain (1) a $k \\times 1$ randomizer vector $y$ with coefficients in the range $\\eta_1$, a $k \\times 1$ noise vector $e_1$ with coefficients in the range $\\eta_2$, and a noise polynomial $e_2$ with coefficients in the range $\\eta_2$. The values of $y$, $e_1$, and $e_2$ are shown below. Immediately following this step, $y$ is converted into its NTT representation, $\hat{y}$, and so that output is also given here.",
        "action": encaps_step_3
    },
    {
        "title": "Encoding Information about $K$",
        "description": "Now that Bob has all of the pieces he needs to carry out the encapsulation process, the question becomes how to securely transmit the secret key, $K$, over to Alice. As a reminder, $K$ was generated by passing particular seeds into the hash functions $H$ and $G$, and these functions are deterministic. They solely depend on the inputted seeds, so entering the same seeds will produce the same output. Since Alice already has one of these seeds ($ek$), Bob simply needs to transmit the other one, $m$, which he generated in the first step. He begins this process by passing $m$ through the Byte Decode function, which converts it from an array of 32 8-bit integers into 256 1-bit integers (so just 0s and 1s). Then, this array is entered into the Decompress function, which converts each bit into a full 12-bit version. What this means practically is that every 0 is mapped to 0, and every 1 is mapped to 1665, which is $\\lceil \\frac{q}{2} \\rceil$. Why? Because Alice needs to be able to separate out this message from the noise distributions, so using 1665 instead of 1 ensures that the information doesn't get lost. At the end of this step, we have our array of 0s and 1665s, $\\mu$, which represents a polynomial in $R_q$.",
        "action": encaps_step_4
    },
    {
        "title": "Building the First Part of the Ciphertext: $u$",
        "description": "At this point, Bob can begin to construct the variables $v$ and $u$ that will ultimately be compressed into the ciphertext that he sends back to Alice. The basic idea is that $v$ will contain information about the secret key $K$, but in order for Alice to obtain that info, she needs to learn about the randomizer vector, $y$. Our variable, $u$, will contain that necessary information about $y$ -- info which can only be deciphered if the person on the other end has possesssion of the secret vector $s$, which Alice does. So, in this step, Bob calculates $u$. Using the $\hat{A}$ matrix that he reconstructed and the NTT representation of the randomizer vector, $\hat{y}$, computed two steps ago, Bob computes $\hat{A}^T \cdot \hat{y}$. He runs the result through the inverse NTT function to get out $A^T \cdot y$ and adds the resulting $k \\times 1$ vector to the noise vector, $e_1$ to obtain $u$. The value of $u$ in our iteration of the encapsulation process is given below: ",
        "action": encaps_step_5
    },
    {
        "title": "Building the Second Part of the Ciphertext: $v$",
        "description": "As mentioned in the previous step, the second part of the eventual ciphertext, $v$, will contain information that can be used to procure the shared secret key, $K$. To calculate it, Bob first comptutes $\hat{t}^T \cdot \hat{y}$ and uses the inverse NTT function to obtain $t^T \cdot y$. This result (a $1 \\times 1$ polynomial) is then added to the noise polynomial $e_2$ and the special polynomial $\\mu$ encoding information about $m$ (and therefore $K$). The coefficient array for polynomial $v$ is shown below:",
        "action": encaps_step_6
    },
    {
        "title": "Packaging Up the Ciphertext",
        "description": "Time for Bob to package up his ciphertext to send back over to Alice. Just as Alice didn't directly send her public key $(\hat{t}, \hat{A})$ to Bob to add another layer of security, niehter will Bob with his $u$ and $v$ variables. Each one is first compressed -- $u$ into an array of 10- or 11-bit integers (depending on the value of model parameter $d_u$) and $v$ into an array of 4- or 5-bit integers (depending on the value of the model paramter $d_v$). They are both then encoded as byte arrays for standardization and efficiency. Finally, the concatenation of the compressed byte array of $u$ (now called $c_1$) and the compressed byte array of $v$ (now called $c_2$) are returned as Bob's ciphertext $c$. This is what he sends over to Alice at the end of the encapsulation procedure. The output is given below:",
        "action": encaps_step_7
    }
]

DECAPSULATION_STEPS = [
    {
        "title": "Deciphering $u$ from Alice's Ciphertext",
        "description": "Here's the idea. Bob has sent Alice a ciphertext. Within that ciphertext there are two components -- $c_1$ and $c_2$. Once converted back to their original forms, $c_1$ and $c_2$ are equivalent to $u$ and $v$, respectively (assuming that they actually came from Bob and that there werent' any errors in decryption). The polynomial $v$ contains information about the secret key $K$ via the polynomial $\\mu$, so Alice wants to recover $\\mu$. To be more specific, $v = t^Ty + e_2 + \\mu$. If Alice knew $t^Ty$, she coudl round $v - t^Ty$ and be able to recover $\\mu$, but she doesn't know what $y$ is. That's why she needs $u$, which equals $A^Ty + e_1$. Now, an ordinary person without any other information wouldn't be able to do anything with $u$, but Alice is not an ordinary person. She knows the secret vector $s$, as in $t = As + e$, and because the original $e$ is a vector with small coefficients, $t \\approx As$. So, what Alice can do is multiply $s^Tu$ to get $s^T(A^Ty + e_1) = (s^TA)y + s^Te_1 \\approx t^Ty + s^Te_1 \\approx t^Ty$ because $e_1$ is so small. She'll then subtract $v - s^Tu = \\mu + noise$ and round the coefficients accordingly to recover $\\mu$ and use it to reconstruct the secret key $K$ that Bob generated during the encapsulation step. \n So, to start off the whole decapsulation process, Alice takes the ciphertext, $c$ from Bob and separates it into $c_1$ and $c_2$, and she starts with $c_1$ (the $u$ component). To recover $u$ (or $u'$ in proper notation in case of bogus ciphertext or decapsulation errors), she runs $c_1$ through the Byte Decode function, which converts it back from a byte array into a vector of polynomials with $d_u$-bit integer coefficients. Then, she passes it through the Decompress function, which returns the coefficients as full 12-bit integers (as they were originally). This should give us back the original $u$ on Bob's end (or something very, very similar). The value of $u'$ in this case is given below:",
        "action": decaps_step_1
    },
    {
        "title": "Deciphering $v$ from Alice's Ciphertext",
        "description": "While she's at it, Alice then takes $c_2$ and carried out a pretty much identical procedure. To recover $v$ (or something very close to it), she passes $c_2$ through the Byte Decode function to convert it from a byte array back into an array of $d_v$-bit integers. This new array is then passed into the Decompress function to get out the array representation of the polynomial $v'$ with full 12-bit integer coefficients. The output of $v'$ is given below:",
        "action": decaps_step_2 
    },
    {
        "title": "Reconstructing $\hat{s}$ from the Decapsulation Key",
        "description": "As stated in the first step, however $u$ and $v$ are useless to Alice unless she has access to the original secret vector $s$. Recall that in the key generation procedure, Alice packaged $\hat{s}$ up into the decapsulation key, $dk$, as the variable 'dk_PKE'. To recover $\hat{s}$, therefore, Alice now takes $dk$ and parses it up into its original components: a random byte array $z$, the encapsulation key $ek$ (which she will use later), a hash of the encapsulation key $h$, and the variable 'dk_PKE'. She passes 'dk_PKE' through the Byte Decode function to convert it back from a byte array into $\hat{s}$, the NTT representation of the secret vector $s$ (a $k \\times 1$ vector of polynomials with 12-bit integer coefficeints). The output of $\hat{s}$ is shown below:",
        "action": decaps_step_3
    },
    {
        "title": "Starting the Process of Recovering $\\mu$",
        "description": "Now, to move in the direction of recovering $\\mu$ (and therefore $m$), Alice first computes the NTT representation of $u'$, which we denote as $\hat{u}'$. This allows her to multiply $\hat{s}^T\hat{u}'$ and take the inverse NTT of the result to get $s^Tu'$, and we define this as our temporary variable, $f$. The value of $f$ is given below:",
        "action": decaps_step_4
    },
    {
        "title": "Recovering $\\mu'$ and Then $m'$",
        "description": "To recover $\\mu$ and therefore $m$ (or $\\mu'$ and $m'$ in proper notation), Alice subtracts $v' - f = v' - s^Tu$, which should be approximately equivalent to $\\mu$ (with some noise). She then passes it through the Compress function to convert the polynomial back to an array of 0s and 1s and uses the Byte Encode function to convert it back into a byte array, $m'$. This should be equal to the byte array $m$ that Bob generated at the beginning of the encapsulation process. The value of Alice's recovered $m'$ is shown below:",
        "action": decaps_step_5
    },
    {
        "title": "Reconstructing $K$ ($K'$)",
        "description": "Now that Alice has recovered $m$ ($m'$), all she needs to do is pass it into the hash function, $G$, as a seed along with the hash of the encapsulation key ($h$), just as Bob did, to get out the same shared secret key $K$ (although we denote this as $K'$ as before). $K'$ is shown below. The process is not over, though. To ensure no errors or bogus attacks in the decapsulation process, Alice will carry out a verification process known as implicit rejection, which starts in the next step.",
        "action": decaps_step_6
    },
    {
        "title": "Doing Implicit Rejection",
        "description": "Alice wants to make sure that (1) there were no errors in the decryption process and (b) that anyone who sends her a bogus ciphertext without actually doing proper key encapsulation wouldn't be able to learn anything form the output of the decapsulation scheme. So, to start, she takes the random byte array $m'$ that she just recovered from the ciphertext and the pseudo-random 32-byte array $r'$ that was produces when she passed $m'$ and $h$ into the hash function $G$ ($K'$ was just one of two outputs). Now, if the ciphertext that Alice received truly came as the output of the ML-KEM encapsulation procedure using her public key, then taking the encapsulation key $ek$ and the seed $r'$ and re-running the entire encapsulation procedure should produce the same exact ciphertext that Alice got from Bob at the start of the procedure. If the two *are* the same, then the procedure returns the $K'$ value that Alice reconstructed in the previous step as the true shared secret key. If the two do *not* evaluate equal to true, then the algorithm carries out what is known as an implicit rejection procedure. Essentially, it returns a fake key of the sake structure and length as $K'$ except containing no information whatsoever that can be used to reconstruct $K'$. It is generated by taking the ciphertext $c$ that Alice received and the random 32-byte array $z$ stored in the decapsulation key for implicit rejection, and passing them into the hash function $J$. This returns a random 32-byte dummy key denoted as $\\bar{K}$. It is worth noting that not even Alice can tell if the decapsulation procedure returned a dummy key or not. She will only find out later when she tries to decrypt a message from 'Bob' using her secret key, $K$, and it fails. Although slightly more inconvenient, this verification/authentication process gives the ML-KEM its CCA-level security. Shown below is the value of $\\bar{K}$ for our current iteration of the decapsulation procedure. Although as previously mentioned, ML-KEM decapsulation will not explicitly tell the user whether it succeeded or failed, for illustrative purposes, the last step will show this result.",
        "action": decaps_step_7
    },
    {
        "title": "ML-KEM Procedure Result",
        "description": "Woohoo! The procedure was a success! Alice and Bob have successfully transmitted a shared secret key, $K$, in a post-quantum world! They can now use this key to send messages to each other using a symmetric (or private-key) encryption scheme.",
        "action": decaps_step_8
    }
]

# -------------------------------------------------------------
# --- Control Functions (Updated to reset all crypto state) ---
# -------------------------------------------------------------

def clear_crypto_state():
    """Helper function to clear all intermediate crypto state variables."""
    st.session_state.rho = None
    st.session_state.sigma = None
    st.session_state.s = None
    st.session_state.e = None
    st.session_state.A_hat = None
    st.session_state.s_hat = None
    st.session_state.e_hat = None
    st.session_state.t_hat = None
    st.session_state.ek = None
    st.session_state.dk = None
    st.session_state.K = None # Shared secret candidate
    st.session_state.r = None
    st.session_state.m = None # Seed m 
    st.session_state.mu = None
    st.session_state.y = None
    st.session_state.y_hat = None
    st.session_state.e_1 = None
    st.session_state.e_2 = None
    st.session_state.u = None
    st.session_state.v = None
    st.session_state.c = None
    st.session_state.u_prime = None
    st.session_state.v_prime = None
    st.session_state.f = None
    st.session_state.s_hat_prime = None
    st.session_state.m_prime = None
    st.session_state.K_prime = None
    st.session_state.K_bar = None
    st.session_state.message = None
    st.session_state.returned_key = None
    st.session_state.dk_PKE = None
    st.session_state.ek_PKE = None
    st.session_state.h = None
    st.session_state.z = None

def start_walkthrough(phase):
    """Starts the KeyGen or Encapsulation or Decapsulation walkthrough."""
    st.session_state.selected_kyber = st.session_state.selected_kyber_input
    # Clear Encapsulation state if starting KeyGen fresh
    if phase == 'KeyGen':
        clear_crypto_state() 
    
    st.session_state.walkthrough_phase = phase
    st.session_state.walkthrough_step = 0 # Start at index 0 (Step 1)

def on_kyber_change():
    """Called when the parameter set changes."""
    st.session_state.selected_kyber = st.session_state.selected_kyber_input
    clear_crypto_state()
    st.session_state.walkthrough_phase = 'None'
    st.session_state.walkthrough_step = -1

def previous_step():
    """Goes back to the previous step in the current phase."""
    if st.session_state.walkthrough_step > 0:
        st.session_state.walkthrough_step -= 1
    elif st.session_state.walkthrough_phase == 'Encapsulation':
        # If on Encapsulation Step 1, go back to KeyGen completion screen
        st.session_state.walkthrough_phase = 'KeyGen'
        st.session_state.walkthrough_step = len(KEYGEN_STEPS) - 1 # Index of Step 6
    elif st.session_state.walkthrough_phase == 'Decapsulation':
        # If on Encapsulation Step 1, go back to KeyGen completion screen
        st.session_state.walkthrough_phase = 'Encapsulation'
        st.session_state.walkthrough_step = len(ENCAPSULATION_STEPS) - 1 # Index of Step 6

def next_step():
    """Advances the walkthrough, handling phase transitions."""
    current_phase = st.session_state.walkthrough_phase
    current_step = st.session_state.walkthrough_step
    
    if current_phase == 'KeyGen':
        if current_step < len(KEYGEN_STEPS) - 1:
            st.session_state.walkthrough_step += 1
        else:
            # Key Generation finished, transition to Encapsulation start
            st.session_state.walkthrough_phase = 'Encapsulation'
            st.session_state.walkthrough_step = 0 # Start Encapsulation at Step 1 (index 0)
    
    elif current_phase == 'Encapsulation':
        if current_step < len(ENCAPSULATION_STEPS) - 1:
            st.session_state.walkthrough_step += 1
        else:
            # Encapsulation finished, transition to Decapsulation start
            st.session_state.walkthrough_phase = 'Decapsulation'
            st.session_state.walkthrough_step = 0 # Start Decapsulation at Step 1 (index 0)
    
    elif current_phase == "Decapsulation":
        if current_step < len(DECAPSULATION_STEPS) - 1:
            st.session_state.walkthrough_step += 1

def reset_walkthrough():
    """Sets the walkthrough back to the start state, clearing all data."""
    clear_crypto_state()
    st.session_state.walkthrough_phase = 'None'
    st.session_state.walkthrough_step = -1

with tab2:
    st.markdown("## Complete ML-KEM Walkthrough")

    st.markdown(
        "Select an ML-KEM parameter set below and click **'Start Walkthrough'** to begin a step-by-step demonstration of the initial Key Generation process. The main difference between the parameter sets is the variable $k$, which determines the size of the coefficient vectors and the public key matrix $\hat{A}$. A larger $k$ increases the security of the cryptosystem by increasing the size of the encapsulation/decapsulation keys and the ciphertext, but it also results in a larger performance cost."
    )

    st.markdown(
        "It is worth noting, however, that in all approved parameter sets, the modulus $q$ takes a value of 3329. This means that all polynomial coefficients in our ring $R_q$ are integers in [0, 3328]. Furthermore, the polynomial degree $n$ is always equal to 256, so every polynomial in $R_q$ is of the 255-th degree, and every coefficient array has a length of 256. Lastly, in all three parameter sets, the size of the shared secret key, K, that Bob generates and sends in a ciphertext to Alice, is 32 bytes (256 bits)."
    )

    col_select, col_start_key_gen, col_reset_all = st.columns([2, 1, 1])

    kyber_choice = col_select.pills(
        "Select a parameter set to begin:",
        options=list(KYBER_PARAMS.keys()),
        key='selected_kyber_input',
        default = list(KYBER_PARAMS.keys())[1],
        on_change = on_kyber_change
    )

    if st.session_state.walkthrough_phase == 'None':
        col_start_key_gen.button(
            "ğŸš€ Start Key Generation", 
            on_click=lambda: start_walkthrough('KeyGen'), 
            type="primary",
            use_container_width=True
        )

    if st.session_state.walkthrough_phase != 'None':
        col_reset_all.button(
            "ğŸ”„ Reset All", 
            on_click=reset_walkthrough, 
            type="secondary",
            use_container_width=True,
            help="Reset walkthrough and clear all intermediate cryptographic data."
        )

    st.divider()

    # --- Walkthrough Display Logic ---
    current_phase = st.session_state.walkthrough_phase
    current_step_index = st.session_state.walkthrough_step

    if current_phase != 'None':
        params = KYBER_PARAMS[st.session_state.selected_kyber]
        
        # --- PHASE 1: KEY GENERATION ---
        if current_phase == 'KeyGen':
            
            st.markdown("## ğŸ”‘ Key Generation (Alice)")
            
            # This handles steps 1 through 6
            if current_step_index < len(KEYGEN_STEPS):
                step_list = KEYGEN_STEPS
                step_data = step_list[current_step_index]

                # Step Title and Progress
                st.markdown(f" ### Step {current_step_index + 1} of {len(step_list)}: {step_data['title']}")

                # Description
                st.markdown(step_data['description'])

                # Output / Action
                if current_step_index in [1,2,3,4,5,6]:
                    full_output = st.toggle("Show full output", value = False)
                    if full_output:
                        output = step_data['action'](params, True)
                    else:
                        output = step_data['action'](params, False)
                else:
                    output = step_data['action'](params)
                st.code(output, language='text')

                if current_step_index == len(KEYGEN_STEPS) - 1:
                    # Key Generation Completion message, appearing right above the nav controls
                    st.success("âœ… **Key Generation Complete!** Alice now sends her public encapsulation key ($\mathbf{ek}$) over to Bob. Click the button below to continue.")
            
        # --- PHASE 2: ENCAPSULATION ---
        elif current_phase == 'Encapsulation':
            st.header("ğŸ”’ Encapsulation Walkthrough (Bob)")
            
            if current_step_index < len(ENCAPSULATION_STEPS):
                step_list = ENCAPSULATION_STEPS
                step_data = step_list[current_step_index]

                # Step Title and Progress
                st.subheader(f"Step {current_step_index + 1} of {len(step_list)}: {step_data['title']}")

                # Description
                st.markdown(step_data['description'])

                # Output / Action
                if current_step_index in [1,2,3,4,5,6]:
                    full_output = st.toggle("Show full output", value = False)
                    if full_output:
                        output = step_data['action'](params, True)
                    else:
                        output = step_data['action'](params, False)
                else:
                    output = step_data['action'](params)
                st.code(output, language='text')
            
            if current_step_index == len(ENCAPSULATION_STEPS) - 1:
                st.success("ğŸ‰ **Encapsulation Complete!** Bob keeps his copy of the shared secret and sends the ciphertext over to Alice. Click the button below to continue")
        
         # --- PHASE 2: DECAPSULATION ---
        elif current_phase == 'Decapsulation':
            st.header("ğŸ”“ Decapsulation Walkthrough (Alice)")
            
            if current_step_index < len(DECAPSULATION_STEPS):
                step_list = DECAPSULATION_STEPS
                step_data = step_list[current_step_index]

                # Step Title and Progress
                st.subheader(f"Step {current_step_index + 1} of {len(step_list)}: {step_data['title']}")

                # Description
                st.markdown(step_data['description'])

                # Output / Action
                if current_step_index in [0,1,2,3]:
                    full_output = st.toggle("Show full output", value = False)
                    if full_output:
                        output = step_data['action'](params, True)
                    else:
                        output = step_data['action'](params, False)
                else:
                    output = step_data['action'](params)
                st.code(output, language='text')
            
            if current_step_index == len(DECAPSULATION_STEPS) - 1:
                st.balloons()
                st.success("ğŸ‰ **Decapsulation Complete!** Better luck next time, hackers.")

        # --- Controls for Active Phase ---
        col_prev, col_next = st.columns([1, 1])

        # Previous Button Logic
        # Disabled if on KeyGen Step 1 (index 0)
        col_prev.button(
            "â¬…ï¸ Previous Step", 
            on_click=previous_step, 
            disabled=(current_step_index == 0 and current_phase == 'KeyGen'),
            use_container_width=True,
            help="Go back to the previous step in the current process."
        )
        
        # Next Button Label and Logic
        next_button_label = "â¡ï¸ Next Step"
        next_disabled = False

        if current_phase == 'KeyGen' and current_step_index == len(KEYGEN_STEPS) - 1:
            # Custom label for the transition point
            next_button_label = "ğŸ”’ Begin Encapsulation Walkthrough"
        if current_phase == 'Encapsulation' and current_step_index == len(ENCAPSULATION_STEPS) - 1:
            # Custom label for the transition point
            next_button_label = "ğŸ”“ Begin Decapsulation Walkthrough"
        elif current_phase == 'Decapsulation' and current_step_index == len(DECAPSULATION_STEPS) - 1:
             # Disabled if on the last Encapsulation step
            next_disabled = True
            
        col_next.button(
            next_button_label, 
            on_click=next_step, 
            disabled=next_disabled, 
            type="primary",
            use_container_width=True,
            help="Advance to the next step or the next walkthrough phase."
        )


with tab3:
    st.write("Blah blah blah")